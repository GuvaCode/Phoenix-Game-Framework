{ ============================================================================
  This file is autogenerated from vk.xml
  You may retrieve the latest version of this file at the Delphi OpenGL
  Community home page, located at http://www.delphigl.com/
  
  The contents of this file are used with permission, subject to
  the Mozilla Public License Version 1.1 (the "License"); you may
  not use this file except in compliance with the License. You may
  obtain a copy of the License at
  http://www.mozilla.org/MPL/MPL-1.1.html
  
  Software distributed under the License is distributed on an
  "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
  implied. See the License for the specific language governing
  rights and limitations under the License.

Original vk.xml comment:
==============================================================================
Copyright (c) 2015-2016 The Khronos Group Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and/or associated documentation files (the
"Materials"), to deal in the Materials without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Materials, and to
permit persons to whom the Materials are furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Materials.

THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

------------------------------------------------------------------------

This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The only authoritative version of vk.xml is the one
maintained in the master branch of the Khronos Vulkan Github project.

============================================================================ }
  
unit Vulkan;

{$IFDEF FPC}
  {$MODE Delphi}
  {$IFNDEF WINDOWS}
    {$LINKLIB c}
  {$ENDIF}
  {$MINENUMSIZE 4}
  {$PACKSET 4}  
{$ENDIF}

{$I Vulkan.inc}

interface

type
  VkUint8                   = Byte;
  VkUint16                  = Word;
  VkUint32                  = Cardinal;
  VkUint64                  = QWord;
  VkInt16                   = SmallInt;
  VkInt32                   = Integer;
  VkInt64                   = Int64;
  VkFloat                   = Single;
  VkDouble                  = Double;
  VkChar                    = AnsiChar;
  VkSize                    = SizeUInt;
  VkHandle                  = Pointer;
  VkNonDispatchableHandle   = {$IFDEF VK_CPU64}Pointer{$ELSE}VkUint64{$ENDIF};

const
  VK_INVALID_HANDLE:     VkHandle                = nil;
  VK_INVALID_NDP_HANDLE: VkNonDispatchableHandle = {$IFDEF VK_CPU64}nil{$ELSE}0{$ENDIF};

type
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  HINSTANCE = VkHandle;
  HWND      = VkHandle;
{$ENDIF}

  PVkVoid   = Pointer;
  PVkHandle = ^VkHandle;
  PVkUint8  = ^VkUint8;
  PVkUint16 = ^VkUint16;
  PVkUint32 = ^VkUint32;
  PVkUint64 = ^VkUint64;
  PVkInt16  = ^VkInt16;
  PVkInt32  = ^VkInt32;
  PVkInt64  = ^VkInt64;
  PVkFloat  = ^VkFloat;
  PVkDouble = ^VkDouble;
  PVkChar   = ^VkChar;
  PVkSize   = ^VkSize;
  
  PPVkVoid   = ^PVkVoid;
  PPVkHandle = ^PVkHandle;
  PPVkUint8  = ^PVkUint8;
  PPVkUint16 = ^PVkUint16;
  PPVkUint32 = ^PVkUint32;
  PPVkUint64 = ^PVkUint64;
  PPVkInt16  = ^PVkInt16;
  PPVkInt32  = ^PVkInt32;
  PPVkInt64  = ^PVkInt64;
  PPVkFloat  = ^PVkFloat;
  PPVkDouble = ^PVkDouble;
  PPVkChar   = ^PVkChar;
  PPVkSize   = ^PVkSize;

const
  VK_API_VERSION                                                 = 4194307;
  VK_API_VERSION_MAJOR                                           = 1;
  VK_API_VERSION_MINOR                                           = 0;
  VK_API_VERSION_BUGFIX                                          = 3;

{ ========================================== VK_VERSION_1_0 ========================================== }
  VK_LOD_CLAMP_NONE                                              = 1000;
  VK_REMAINING_MIP_LEVELS                                        = $FFFFFFFF;
  VK_REMAINING_ARRAY_LAYERS                                      = $FFFFFFFF;
  VK_WHOLE_SIZE                                                  = $FFFFFFFF;
  VK_ATTACHMENT_UNUSED                                           = $FFFFFFFF;
  VK_TRUE                                                        = 1;
  VK_FALSE                                                       = 0;
  VK_QUEUE_FAMILY_IGNORED                                        = $FFFFFFFF;
  VK_SUBPASS_EXTERNAL                                            = $FFFFFFFF;
  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE                               = 256;
  VK_UUID_SIZE                                                   = 16;
  VK_MAX_MEMORY_TYPES                                            = 32;
  VK_MAX_MEMORY_HEAPS                                            = 16;
  VK_MAX_EXTENSION_NAME_SIZE                                     = 256;
  VK_MAX_DESCRIPTION_SIZE                                        = 256;

{ ========================================== VK_KHR_surface ========================================== }
  VK_KHR_SURFACE_SPEC_VERSION                                    = 25;
  VK_KHR_SURFACE_EXTENSION_NAME                                  = 'VK_KHR_surface';

{ ========================================= VK_KHR_swapchain ========================================= }
  VK_KHR_SWAPCHAIN_SPEC_VERSION                                  = 67;
  VK_KHR_SWAPCHAIN_EXTENSION_NAME                                = 'VK_KHR_swapchain';

{ ========================================== VK_KHR_display ========================================== }
  VK_KHR_DISPLAY_SPEC_VERSION                                    = 21;
  VK_KHR_DISPLAY_EXTENSION_NAME                                  = 'VK_KHR_display';

{ ===================================== VK_KHR_display_swapchain ===================================== }
  VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION                          = 9;
  VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME                        = 'VK_KHR_display_swapchain';

{ ======================================= VK_KHR_xlib_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  VK_KHR_XLIB_SURFACE_SPEC_VERSION                               = 6;
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME                             = 'VK_KHR_xlib_surface';
{$ENDIF}

{ ======================================== VK_KHR_xcb_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  VK_KHR_XCB_SURFACE_SPEC_VERSION                                = 6;
  VK_KHR_XCB_SURFACE_EXTENSION_NAME                              = 'VK_KHR_xcb_surface';
{$ENDIF}

{ ====================================== VK_KHR_wayland_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  VK_KHR_WAYLAND_SURFACE_SPEC_VERSION                            = 5;
  VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME                          = 'VK_KHR_wayland_surface';
{$ENDIF}

{ ======================================== VK_KHR_mir_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  VK_KHR_MIR_SURFACE_SPEC_VERSION                                = 4;
  VK_KHR_MIR_SURFACE_EXTENSION_NAME                              = 'VK_KHR_mir_surface';
{$ENDIF}

{ ====================================== VK_KHR_android_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  VK_KHR_ANDROID_SURFACE_SPEC_VERSION                            = 6;
  VK_KHR_ANDROID_SURFACE_EXTENSION_NAME                          = 'VK_KHR_android_surface';
{$ENDIF}

{ ======================================= VK_KHR_win32_surface ======================================= }
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  VK_KHR_WIN32_SURFACE_SPEC_VERSION                              = 5;
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME                            = 'VK_KHR_win32_surface';
{$ENDIF}

{ ======================================= VK_EXT_debug_report ======================================== }
  VK_EXT_DEBUG_REPORT_SPEC_VERSION                               = 1;
  VK_EXT_DEBUG_REPORT_EXTENSION_NAME                             = 'VK_EXT_debug_report';

type { enumerations }

{ ========================================== VK_VERSION_1_0 ========================================== }
  TVkPipelineCacheHeaderVersion = (
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE                         = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM                    = $7FFFFFFF
  );
  PVkPipelineCacheHeaderVersion = ^TVkPipelineCacheHeaderVersion;
  PPVkPipelineCacheHeaderVersion = ^PVkPipelineCacheHeaderVersion;

  TVkResult = (
    VK_SUCCESS                                                   = 0,
    VK_NOT_READY                                                 = 1,
    VK_TIMEOUT                                                   = 2,
    VK_EVENT_SET                                                 = 3,
    VK_EVENT_RESET                                               = 4,
    VK_INCOMPLETE                                                = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY                                  = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY                                = -2,
    VK_ERROR_INITIALIZATION_FAILED                               = -3,
    VK_ERROR_DEVICE_LOST                                         = -4,
    VK_ERROR_MEMORY_MAP_FAILED                                   = -5,
    VK_ERROR_LAYER_NOT_PRESENT                                   = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT                               = -7,
    VK_ERROR_FEATURE_NOT_PRESENT                                 = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER                                 = -9,
    VK_ERROR_TOO_MANY_OBJECTS                                    = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED                                = -11,
    VK_ERROR_SURFACE_LOST_KHR                                    = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR                            = -1000000001,
    VK_SUBOPTIMAL_KHR                                            = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR                                     = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR                            = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT                               = -1000011001,
    VK__MAX_ENUM                                                 = $7FFFFFFF
  );
  PVkResult = ^TVkResult;
  PPVkResult = ^PVkResult;

  TVkStructureType = (
    VK_STRUCTURE_TYPE_APPLICATION_INFO                           = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                       = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                   = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                         = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO                                = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO                       = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                        = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO                           = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                          = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                      = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                          = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                     = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                         = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                    = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                          = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                     = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                  = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                 = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO          = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO    = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO  = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO    = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO        = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO   = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO     = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO   = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO     = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO         = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO              = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO               = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO                = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                        = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO          = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO                = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO               = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                       = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                        = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                    = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                    = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO                   = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO               = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO            = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO                  = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                     = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                      = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                       = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER                             = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO                = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO                  = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR                  = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR                           = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR               = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR            = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR                   = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR               = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR                = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR            = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR                = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR            = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR              = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT               = 1000011000,
    VK_STRUCTURE_TYPE_MAX_ENUM                                   = $7FFFFFFF
  );
  PVkStructureType = ^TVkStructureType;
  PPVkStructureType = ^PVkStructureType;

  TVkSystemAllocationScope = (
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND                           = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT                            = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE                             = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE                            = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE                          = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM                          = $7FFFFFFF
  );
  PVkSystemAllocationScope = ^TVkSystemAllocationScope;
  PPVkSystemAllocationScope = ^PVkSystemAllocationScope;

  TVkInternalAllocationType = (
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE                       = 0,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM                         = $7FFFFFFF
  );
  PVkInternalAllocationType = ^TVkInternalAllocationType;
  PPVkInternalAllocationType = ^PVkInternalAllocationType;

  TVkFormat = (
    VK_FORMAT_UNDEFINED                                          = 0,
    VK_FORMAT_R4G4_UNORM_PACK8                                   = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16                              = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16                              = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16                                = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16                                = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16                              = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16                              = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16                              = 8,
    VK_FORMAT_R8_UNORM                                           = 9,
    VK_FORMAT_R8_SNORM                                           = 10,
    VK_FORMAT_R8_USCALED                                         = 11,
    VK_FORMAT_R8_SSCALED                                         = 12,
    VK_FORMAT_R8_UINT                                            = 13,
    VK_FORMAT_R8_SINT                                            = 14,
    VK_FORMAT_R8_SRGB                                            = 15,
    VK_FORMAT_R8G8_UNORM                                         = 16,
    VK_FORMAT_R8G8_SNORM                                         = 17,
    VK_FORMAT_R8G8_USCALED                                       = 18,
    VK_FORMAT_R8G8_SSCALED                                       = 19,
    VK_FORMAT_R8G8_UINT                                          = 20,
    VK_FORMAT_R8G8_SINT                                          = 21,
    VK_FORMAT_R8G8_SRGB                                          = 22,
    VK_FORMAT_R8G8B8_UNORM                                       = 23,
    VK_FORMAT_R8G8B8_SNORM                                       = 24,
    VK_FORMAT_R8G8B8_USCALED                                     = 25,
    VK_FORMAT_R8G8B8_SSCALED                                     = 26,
    VK_FORMAT_R8G8B8_UINT                                        = 27,
    VK_FORMAT_R8G8B8_SINT                                        = 28,
    VK_FORMAT_R8G8B8_SRGB                                        = 29,
    VK_FORMAT_B8G8R8_UNORM                                       = 30,
    VK_FORMAT_B8G8R8_SNORM                                       = 31,
    VK_FORMAT_B8G8R8_USCALED                                     = 32,
    VK_FORMAT_B8G8R8_SSCALED                                     = 33,
    VK_FORMAT_B8G8R8_UINT                                        = 34,
    VK_FORMAT_B8G8R8_SINT                                        = 35,
    VK_FORMAT_B8G8R8_SRGB                                        = 36,
    VK_FORMAT_R8G8B8A8_UNORM                                     = 37,
    VK_FORMAT_R8G8B8A8_SNORM                                     = 38,
    VK_FORMAT_R8G8B8A8_USCALED                                   = 39,
    VK_FORMAT_R8G8B8A8_SSCALED                                   = 40,
    VK_FORMAT_R8G8B8A8_UINT                                      = 41,
    VK_FORMAT_R8G8B8A8_SINT                                      = 42,
    VK_FORMAT_R8G8B8A8_SRGB                                      = 43,
    VK_FORMAT_B8G8R8A8_UNORM                                     = 44,
    VK_FORMAT_B8G8R8A8_SNORM                                     = 45,
    VK_FORMAT_B8G8R8A8_USCALED                                   = 46,
    VK_FORMAT_B8G8R8A8_SSCALED                                   = 47,
    VK_FORMAT_B8G8R8A8_UINT                                      = 48,
    VK_FORMAT_B8G8R8A8_SINT                                      = 49,
    VK_FORMAT_B8G8R8A8_SRGB                                      = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32                              = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32                              = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32                            = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32                            = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32                               = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32                               = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32                               = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32                           = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32                           = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32                         = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32                         = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32                            = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32                            = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32                           = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32                           = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32                         = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32                         = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32                            = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32                            = 69,
    VK_FORMAT_R16_UNORM                                          = 70,
    VK_FORMAT_R16_SNORM                                          = 71,
    VK_FORMAT_R16_USCALED                                        = 72,
    VK_FORMAT_R16_SSCALED                                        = 73,
    VK_FORMAT_R16_UINT                                           = 74,
    VK_FORMAT_R16_SINT                                           = 75,
    VK_FORMAT_R16_SFLOAT                                         = 76,
    VK_FORMAT_R16G16_UNORM                                       = 77,
    VK_FORMAT_R16G16_SNORM                                       = 78,
    VK_FORMAT_R16G16_USCALED                                     = 79,
    VK_FORMAT_R16G16_SSCALED                                     = 80,
    VK_FORMAT_R16G16_UINT                                        = 81,
    VK_FORMAT_R16G16_SINT                                        = 82,
    VK_FORMAT_R16G16_SFLOAT                                      = 83,
    VK_FORMAT_R16G16B16_UNORM                                    = 84,
    VK_FORMAT_R16G16B16_SNORM                                    = 85,
    VK_FORMAT_R16G16B16_USCALED                                  = 86,
    VK_FORMAT_R16G16B16_SSCALED                                  = 87,
    VK_FORMAT_R16G16B16_UINT                                     = 88,
    VK_FORMAT_R16G16B16_SINT                                     = 89,
    VK_FORMAT_R16G16B16_SFLOAT                                   = 90,
    VK_FORMAT_R16G16B16A16_UNORM                                 = 91,
    VK_FORMAT_R16G16B16A16_SNORM                                 = 92,
    VK_FORMAT_R16G16B16A16_USCALED                               = 93,
    VK_FORMAT_R16G16B16A16_SSCALED                               = 94,
    VK_FORMAT_R16G16B16A16_UINT                                  = 95,
    VK_FORMAT_R16G16B16A16_SINT                                  = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT                                = 97,
    VK_FORMAT_R32_UINT                                           = 98,
    VK_FORMAT_R32_SINT                                           = 99,
    VK_FORMAT_R32_SFLOAT                                         = 100,
    VK_FORMAT_R32G32_UINT                                        = 101,
    VK_FORMAT_R32G32_SINT                                        = 102,
    VK_FORMAT_R32G32_SFLOAT                                      = 103,
    VK_FORMAT_R32G32B32_UINT                                     = 104,
    VK_FORMAT_R32G32B32_SINT                                     = 105,
    VK_FORMAT_R32G32B32_SFLOAT                                   = 106,
    VK_FORMAT_R32G32B32A32_UINT                                  = 107,
    VK_FORMAT_R32G32B32A32_SINT                                  = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT                                = 109,
    VK_FORMAT_R64_UINT                                           = 110,
    VK_FORMAT_R64_SINT                                           = 111,
    VK_FORMAT_R64_SFLOAT                                         = 112,
    VK_FORMAT_R64G64_UINT                                        = 113,
    VK_FORMAT_R64G64_SINT                                        = 114,
    VK_FORMAT_R64G64_SFLOAT                                      = 115,
    VK_FORMAT_R64G64B64_UINT                                     = 116,
    VK_FORMAT_R64G64B64_SINT                                     = 117,
    VK_FORMAT_R64G64B64_SFLOAT                                   = 118,
    VK_FORMAT_R64G64B64A64_UINT                                  = 119,
    VK_FORMAT_R64G64B64A64_SINT                                  = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT                                = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32                            = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32                             = 123,
    VK_FORMAT_D16_UNORM                                          = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32                                = 125,
    VK_FORMAT_D32_SFLOAT                                         = 126,
    VK_FORMAT_S8_UINT                                            = 127,
    VK_FORMAT_D16_UNORM_S8_UINT                                  = 128,
    VK_FORMAT_D24_UNORM_S8_UINT                                  = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT                                 = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK                                = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK                                 = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK                               = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK                                = 134,
    VK_FORMAT_BC2_UNORM_BLOCK                                    = 135,
    VK_FORMAT_BC2_SRGB_BLOCK                                     = 136,
    VK_FORMAT_BC3_UNORM_BLOCK                                    = 137,
    VK_FORMAT_BC3_SRGB_BLOCK                                     = 138,
    VK_FORMAT_BC4_UNORM_BLOCK                                    = 139,
    VK_FORMAT_BC4_SNORM_BLOCK                                    = 140,
    VK_FORMAT_BC5_UNORM_BLOCK                                    = 141,
    VK_FORMAT_BC5_SNORM_BLOCK                                    = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK                                  = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK                                  = 144,
    VK_FORMAT_BC7_UNORM_BLOCK                                    = 145,
    VK_FORMAT_BC7_SRGB_BLOCK                                     = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK                            = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK                             = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK                          = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK                           = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK                          = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK                           = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK                                = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK                                = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK                             = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK                             = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK                               = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK                                = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK                               = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK                                = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK                               = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK                                = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK                               = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK                                = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK                               = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK                                = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK                               = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK                                = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK                               = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK                                = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK                               = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK                                = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK                              = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK                               = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK                              = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK                               = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK                              = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK                               = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK                             = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK                              = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK                             = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK                              = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK                             = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK                              = 184,
    VK_FORMAT_MAX_ENUM                                           = $7FFFFFFF
  );
  PVkFormat = ^TVkFormat;
  PPVkFormat = ^PVkFormat;

  TVkFormatFeatureFlagBit = (
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                          = 0,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                          = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT                   = 2,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT                   = 3,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT                   = 4,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT            = 5,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                          = 6,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                       = 7,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT                 = 8,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT               = 9,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT                               = 10,
    VK_FORMAT_FEATURE_BLIT_DST_BIT                               = 11,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT            = 12,
    VK_FORMAT_FEATURE_MAX_BIT                                    = 31
  );
  TVkFormatFeatureFlagBits = set of TVkFormatFeatureFlagBit;

  TVkImageType = (
    VK_IMAGE_TYPE_1D                                             = 0,
    VK_IMAGE_TYPE_2D                                             = 1,
    VK_IMAGE_TYPE_3D                                             = 2,
    VK_IMAGE_TYPE_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkImageType = ^TVkImageType;
  PPVkImageType = ^PVkImageType;

  TVkImageTiling = (
    VK_IMAGE_TILING_OPTIMAL                                      = 0,
    VK_IMAGE_TILING_LINEAR                                       = 1,
    VK_IMAGE_TILING_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkImageTiling = ^TVkImageTiling;
  PPVkImageTiling = ^PVkImageTiling;

  TVkImageUsageFlagBit = (
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT                              = 0,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT                              = 1,
    VK_IMAGE_USAGE_SAMPLED_BIT                                   = 2,
    VK_IMAGE_USAGE_STORAGE_BIT                                   = 3,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT                          = 4,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT                  = 5,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT                      = 6,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT                          = 7,
    VK_IMAGE_USAGE_MAX_BIT                                       = 31
  );
  TVkImageUsageFlagBits = set of TVkImageUsageFlagBit;

  TVkImageCreateFlagBit = (
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT                           = 0,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT                         = 1,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT                           = 2,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT                           = 3,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT                          = 4,
    VK_IMAGE_CREATE_MAX_BIT                                      = 31
  );
  TVkImageCreateFlagBits = set of TVkImageCreateFlagBit;

  TVkSampleCountFlagBit = (
    VK_SAMPLE_COUNT_1_BIT                                        = 0,
    VK_SAMPLE_COUNT_2_BIT                                        = 1,
    VK_SAMPLE_COUNT_4_BIT                                        = 2,
    VK_SAMPLE_COUNT_8_BIT                                        = 3,
    VK_SAMPLE_COUNT_16_BIT                                       = 4,
    VK_SAMPLE_COUNT_32_BIT                                       = 5,
    VK_SAMPLE_COUNT_64_BIT                                       = 6,
    VK_SAMPLE_COUNT_MAX_BIT                                      = 31
  );
  TVkSampleCountFlagBits = set of TVkSampleCountFlagBit;

  TVkPhysicalDeviceType = (
    VK_PHYSICAL_DEVICE_TYPE_OTHER                                = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU                       = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU                         = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU                          = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU                                  = 4,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM                             = $7FFFFFFF
  );
  PVkPhysicalDeviceType = ^TVkPhysicalDeviceType;
  PPVkPhysicalDeviceType = ^PVkPhysicalDeviceType;

  TVkQueueFlagBit = (
    VK_QUEUE_GRAPHICS_BIT                                        = 0,
    VK_QUEUE_COMPUTE_BIT                                         = 1,
    VK_QUEUE_TRANSFER_BIT                                        = 2,
    VK_QUEUE_SPARSE_BINDING_BIT                                  = 3,
    VK_QUEUE_MAX_BIT                                             = 31
  );
  TVkQueueFlagBits = set of TVkQueueFlagBit;

  TVkMemoryPropertyFlagBit = (
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT                          = 0,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                          = 1,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT                         = 2,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT                           = 3,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                      = 4,
    VK_MEMORY_PROPERTY_MAX_BIT                                   = 31
  );
  TVkMemoryPropertyFlagBits = set of TVkMemoryPropertyFlagBit;

  TVkMemoryHeapFlagBit = (
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT                              = 0,
    VK_MEMORY_HEAP_DEVICE_LOCAL_BITMAX_BIT                       = 31
  );
  TVkMemoryHeapFlagBits = set of TVkMemoryHeapFlagBit;

  TVkPipelineStageFlagBit = (
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                            = 0,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                          = 1,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                           = 2,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                          = 3,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT            = 4,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT         = 5,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                        = 6,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                        = 7,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT                   = 8,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT                    = 9,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT                = 10,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                         = 11,
    VK_PIPELINE_STAGE_TRANSFER_BIT                               = 12,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT                         = 13,
    VK_PIPELINE_STAGE_HOST_BIT                                   = 14,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT                           = 15,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT                           = 16,
    VK_PIPELINE_STAGE_MAX_BIT                                    = 31
  );
  TVkPipelineStageFlagBits = set of TVkPipelineStageFlagBit;

  TVkImageAspectFlagBit = (
    VK_IMAGE_ASPECT_COLOR_BIT                                    = 0,
    VK_IMAGE_ASPECT_DEPTH_BIT                                    = 1,
    VK_IMAGE_ASPECT_STENCIL_BIT                                  = 2,
    VK_IMAGE_ASPECT_METADATA_BIT                                 = 3,
    VK_IMAGE_ASPECT_MAX_BIT                                      = 31
  );
  TVkImageAspectFlagBits = set of TVkImageAspectFlagBit;

  TVkSparseImageFormatFlagBit = (
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT                    = 0,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT                  = 1,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT            = 2,
    VK_SPARSE_IMAGE_FORMAT_MAX_BIT                               = 31
  );
  TVkSparseImageFormatFlagBits = set of TVkSparseImageFormatFlagBit;

  TVkSparseMemoryBindFlagBit = (
    VK_SPARSE_MEMORY_BIND_METADATA_BIT                           = 0,
    VK_SPARSE_MEMORY_BIND_METADATA_BITMAX_BIT                    = 31
  );
  TVkSparseMemoryBindFlagBits = set of TVkSparseMemoryBindFlagBit;

  TVkFenceCreateFlagBit = (
    VK_FENCE_CREATE_SIGNALED_BIT                                 = 0,
    VK_FENCE_CREATE_SIGNALED_BITMAX_BIT                          = 31
  );
  TVkFenceCreateFlagBits = set of TVkFenceCreateFlagBit;

  TVkQueryType = (
    VK_QUERY_TYPE_OCCLUSION                                      = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS                            = 1,
    VK_QUERY_TYPE_TIMESTAMP                                      = 2,
    VK_QUERY_TYPE_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkQueryType = ^TVkQueryType;
  PPVkQueryType = ^PVkQueryType;

  TVkQueryPipelineStatisticFlagBit = (
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT      = 0,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT    = 1,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT    = 2,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT  = 3,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT   = 4,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT         = 5,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT          = 6,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT  = 7,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 9,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT   = 10,
    VK_QUERY_PIPELINE_STATISTIC_MAX_BIT                          = 31
  );
  TVkQueryPipelineStatisticFlagBits = set of TVkQueryPipelineStatisticFlagBit;

  TVkQueryResultFlagBit = (
    VK_QUERY_RESULT_64_BIT                                       = 0,
    VK_QUERY_RESULT_WAIT_BIT                                     = 1,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT                        = 2,
    VK_QUERY_RESULT_PARTIAL_BIT                                  = 3,
    VK_QUERY_RESULT_MAX_BIT                                      = 31
  );
  TVkQueryResultFlagBits = set of TVkQueryResultFlagBit;

  TVkBufferCreateFlagBit = (
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT                          = 0,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT                        = 1,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                          = 2,
    VK_BUFFER_CREATE_SPARSE_MAX_BIT                              = 31
  );
  TVkBufferCreateFlagBits = set of TVkBufferCreateFlagBit;

  TVkBufferUsageFlagBit = (
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT                             = 0,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT                             = 1,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT                     = 2,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT                     = 3,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT                           = 4,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT                           = 5,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT                             = 6,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT                            = 7,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT                          = 8,
    VK_BUFFER_USAGE_MAX_BIT                                      = 31
  );
  TVkBufferUsageFlagBits = set of TVkBufferUsageFlagBit;

  TVkSharingMode = (
    VK_SHARING_MODE_EXCLUSIVE                                    = 0,
    VK_SHARING_MODE_CONCURRENT                                   = 1,
    VK_SHARING_MODE_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkSharingMode = ^TVkSharingMode;
  PPVkSharingMode = ^PVkSharingMode;

  TVkImageLayout = (
    VK_IMAGE_LAYOUT_UNDEFINED                                    = 0,
    VK_IMAGE_LAYOUT_GENERAL                                      = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                     = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL             = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL              = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                     = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL                         = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL                         = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED                               = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR                              = 1000001002,
    VK_IMAGE_LAYOUT_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkImageLayout = ^TVkImageLayout;
  PPVkImageLayout = ^PVkImageLayout;

  TVkImageViewType = (
    VK_IMAGE_VIEW_TYPE_1D                                        = 0,
    VK_IMAGE_VIEW_TYPE_2D                                        = 1,
    VK_IMAGE_VIEW_TYPE_3D                                        = 2,
    VK_IMAGE_VIEW_TYPE_CUBE                                      = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY                                  = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY                                  = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY                                = 6,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM                                  = $7FFFFFFF
  );
  PVkImageViewType = ^TVkImageViewType;
  PPVkImageViewType = ^PVkImageViewType;

  TVkComponentSwizzle = (
    VK_COMPONENT_SWIZZLE_IDENTITY                                = 0,
    VK_COMPONENT_SWIZZLE_ZERO                                    = 1,
    VK_COMPONENT_SWIZZLE_ONE                                     = 2,
    VK_COMPONENT_SWIZZLE_R                                       = 3,
    VK_COMPONENT_SWIZZLE_G                                       = 4,
    VK_COMPONENT_SWIZZLE_B                                       = 5,
    VK_COMPONENT_SWIZZLE_A                                       = 6,
    VK_COMPONENT_SWIZZLE_MAX_ENUM                                = $7FFFFFFF
  );
  PVkComponentSwizzle = ^TVkComponentSwizzle;
  PPVkComponentSwizzle = ^PVkComponentSwizzle;

  TVkPipelineCreateFlagBit = (
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT                  = 0,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                     = 1,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT                            = 2,
    VK_PIPELINE_CREATE_MAX_BIT                                   = 31
  );
  TVkPipelineCreateFlagBits = set of TVkPipelineCreateFlagBit;

  TVkShaderStageFlagBit = (
    VK_SHADER_STAGE_VERTEX_BIT                                   = 0,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT                     = 1,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT                  = 2,
    VK_SHADER_STAGE_GEOMETRY_BIT                                 = 3,
    VK_SHADER_STAGE_FRAGMENT_BIT                                 = 4,
    VK_SHADER_STAGE_COMPUTE_BIT                                  = 5,
    VK_SHADER_STAGE_MAX_BIT                                      = 31
  );
  TVkShaderStageFlagBits = set of TVkShaderStageFlagBit;

  TVkVertexInputRate = (
    VK_VERTEX_INPUT_RATE_VERTEX                                  = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE                                = 1,
    VK_VERTEX_INPUT_RATE_MAX_ENUM                                = $7FFFFFFF
  );
  PVkVertexInputRate = ^TVkVertexInputRate;
  PPVkVertexInputRate = ^PVkVertexInputRate;

  TVkPrimitiveTopology = (
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST                             = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST                              = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                             = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                          = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                         = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                           = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY               = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY              = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY           = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY          = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST                             = 10,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM                               = $7FFFFFFF
  );
  PVkPrimitiveTopology = ^TVkPrimitiveTopology;
  PPVkPrimitiveTopology = ^PVkPrimitiveTopology;

  TVkPolygonMode = (
    VK_POLYGON_MODE_FILL                                         = 0,
    VK_POLYGON_MODE_LINE                                         = 1,
    VK_POLYGON_MODE_POINT                                        = 2,
    VK_POLYGON_MODE_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkPolygonMode = ^TVkPolygonMode;
  PPVkPolygonMode = ^PVkPolygonMode;

  TVkCullModeFlagBit = (
    VK_CULL_MODE_FRONT_BIT                                       = 0,
    VK_CULL_MODE_BACK_BIT                                        = 1,
    VK_CULL_MODE_MAX_BIT                                         = 31
  );
  TVkCullModeFlagBits = set of TVkCullModeFlagBit;

  TVkFrontFace = (
    VK_FRONT_FACE_COUNTER_CLOCKWISE                              = 0,
    VK_FRONT_FACE_CLOCKWISE                                      = 1,
    VK_FRONT_FACE_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkFrontFace = ^TVkFrontFace;
  PPVkFrontFace = ^PVkFrontFace;

  TVkCompareOp = (
    VK_COMPARE_OP_NEVER                                          = 0,
    VK_COMPARE_OP_LESS                                           = 1,
    VK_COMPARE_OP_EQUAL                                          = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL                                  = 3,
    VK_COMPARE_OP_GREATER                                        = 4,
    VK_COMPARE_OP_NOT_EQUAL                                      = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL                               = 6,
    VK_COMPARE_OP_ALWAYS                                         = 7,
    VK_COMPARE_OP_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkCompareOp = ^TVkCompareOp;
  PPVkCompareOp = ^PVkCompareOp;

  TVkStencilOp = (
    VK_STENCIL_OP_KEEP                                           = 0,
    VK_STENCIL_OP_ZERO                                           = 1,
    VK_STENCIL_OP_REPLACE                                        = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP                            = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP                            = 4,
    VK_STENCIL_OP_INVERT                                         = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP                             = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP                             = 7,
    VK_STENCIL_OP_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkStencilOp = ^TVkStencilOp;
  PPVkStencilOp = ^PVkStencilOp;

  TVkLogicOp = (
    VK_LOGIC_OP_CLEAR                                            = 0,
    VK_LOGIC_OP_AND                                              = 1,
    VK_LOGIC_OP_AND_REVERSE                                      = 2,
    VK_LOGIC_OP_COPY                                             = 3,
    VK_LOGIC_OP_AND_INVERTED                                     = 4,
    VK_LOGIC_OP_NO_OP                                            = 5,
    VK_LOGIC_OP_XOR                                              = 6,
    VK_LOGIC_OP_OR                                               = 7,
    VK_LOGIC_OP_NOR                                              = 8,
    VK_LOGIC_OP_EQUIVALENT                                       = 9,
    VK_LOGIC_OP_INVERT                                           = 10,
    VK_LOGIC_OP_OR_REVERSE                                       = 11,
    VK_LOGIC_OP_COPY_INVERTED                                    = 12,
    VK_LOGIC_OP_OR_INVERTED                                      = 13,
    VK_LOGIC_OP_NAND                                             = 14,
    VK_LOGIC_OP_SET                                              = 15,
    VK_LOGIC_OP_MAX_ENUM                                         = $7FFFFFFF
  );
  PVkLogicOp = ^TVkLogicOp;
  PPVkLogicOp = ^PVkLogicOp;

  TVkBlendFactor = (
    VK_BLEND_FACTOR_ZERO                                         = 0,
    VK_BLEND_FACTOR_ONE                                          = 1,
    VK_BLEND_FACTOR_SRC_COLOR                                    = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR                          = 3,
    VK_BLEND_FACTOR_DST_COLOR                                    = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR                          = 5,
    VK_BLEND_FACTOR_SRC_ALPHA                                    = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA                          = 7,
    VK_BLEND_FACTOR_DST_ALPHA                                    = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA                          = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR                               = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR                     = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA                               = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA                     = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE                           = 14,
    VK_BLEND_FACTOR_SRC1_COLOR                                   = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR                         = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA                                   = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA                         = 18,
    VK_BLEND_FACTOR_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkBlendFactor = ^TVkBlendFactor;
  PPVkBlendFactor = ^PVkBlendFactor;

  TVkBlendOp = (
    VK_BLEND_OP_ADD                                              = 0,
    VK_BLEND_OP_SUBTRACT                                         = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT                                 = 2,
    VK_BLEND_OP_MIN                                              = 3,
    VK_BLEND_OP_MAX                                              = 4,
    VK_BLEND_OP_MAX_ENUM                                         = $7FFFFFFF
  );
  PVkBlendOp = ^TVkBlendOp;
  PPVkBlendOp = ^PVkBlendOp;

  TVkColorComponentFlagBit = (
    VK_COLOR_COMPONENT_R_BIT                                     = 0,
    VK_COLOR_COMPONENT_G_BIT                                     = 1,
    VK_COLOR_COMPONENT_B_BIT                                     = 2,
    VK_COLOR_COMPONENT_A_BIT                                     = 3,
    VK_COLOR_COMPONENT_MAX_BIT                                   = 31
  );
  TVkColorComponentFlagBits = set of TVkColorComponentFlagBit;

  TVkDynamicState = (
    VK_DYNAMIC_STATE_VIEWPORT                                    = 0,
    VK_DYNAMIC_STATE_SCISSOR                                     = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH                                  = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS                                  = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS                             = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS                                = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK                        = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK                          = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE                           = 8,
    VK_DYNAMIC_STATE_MAX_ENUM                                    = $7FFFFFFF
  );
  PVkDynamicState = ^TVkDynamicState;
  PPVkDynamicState = ^PVkDynamicState;

  TVkFilter = (
    VK_FILTER_NEAREST                                            = 0,
    VK_FILTER_LINEAR                                             = 1,
    VK_FILTER_MAX_ENUM                                           = $7FFFFFFF
  );
  PVkFilter = ^TVkFilter;
  PPVkFilter = ^PVkFilter;

  TVkSamplerMipmapMode = (
    VK_SAMPLER_MIPMAP_MODE_NEAREST                               = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR                                = 1,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM                              = $7FFFFFFF
  );
  PVkSamplerMipmapMode = ^TVkSamplerMipmapMode;
  PPVkSamplerMipmapMode = ^PVkSamplerMipmapMode;

  TVkSamplerAddressMode = (
    VK_SAMPLER_ADDRESS_MODE_REPEAT                               = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT                      = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE                        = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER                      = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE                 = 4,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM                             = $7FFFFFFF
  );
  PVkSamplerAddressMode = ^TVkSamplerAddressMode;
  PPVkSamplerAddressMode = ^PVkSamplerAddressMode;

  TVkBorderColor = (
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK                      = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK                        = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK                           = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK                             = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE                           = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE                             = 5,
    VK_BORDER_COLOR_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkBorderColor = ^TVkBorderColor;
  PPVkBorderColor = ^PVkBorderColor;

  TVkDescriptorType = (
    VK_DESCRIPTOR_TYPE_SAMPLER                                   = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER                    = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE                             = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE                             = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER                      = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER                      = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER                            = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER                            = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC                    = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC                    = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT                          = 10,
    VK_DESCRIPTOR_TYPE_MAX_ENUM                                  = $7FFFFFFF
  );
  PVkDescriptorType = ^TVkDescriptorType;
  PPVkDescriptorType = ^PVkDescriptorType;

  TVkDescriptorPoolCreateFlagBit = (
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT            = 0,
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BITMAX_BIT     = 31
  );
  TVkDescriptorPoolCreateFlagBits = set of TVkDescriptorPoolCreateFlagBit;

  TVkAttachmentDescriptionFlagBit = (
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT                      = 0,
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BITMAX_BIT               = 31
  );
  TVkAttachmentDescriptionFlagBits = set of TVkAttachmentDescriptionFlagBit;

  TVkAttachmentLoadOp = (
    VK_ATTACHMENT_LOAD_OP_LOAD                                   = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR                                  = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE                              = 2,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM                               = $7FFFFFFF
  );
  PVkAttachmentLoadOp = ^TVkAttachmentLoadOp;
  PPVkAttachmentLoadOp = ^PVkAttachmentLoadOp;

  TVkAttachmentStoreOp = (
    VK_ATTACHMENT_STORE_OP_STORE                                 = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE                             = 1,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM                              = $7FFFFFFF
  );
  PVkAttachmentStoreOp = ^TVkAttachmentStoreOp;
  PPVkAttachmentStoreOp = ^PVkAttachmentStoreOp;

  TVkPipelineBindPoint = (
    VK_PIPELINE_BIND_POINT_GRAPHICS                              = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE                               = 1,
    VK_PIPELINE_BIND_POINT_MAX_ENUM                              = $7FFFFFFF
  );
  PVkPipelineBindPoint = ^TVkPipelineBindPoint;
  PPVkPipelineBindPoint = ^PVkPipelineBindPoint;

  TVkAccessFlagBit = (
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT                          = 0,
    VK_ACCESS_INDEX_READ_BIT                                     = 1,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT                          = 2,
    VK_ACCESS_UNIFORM_READ_BIT                                   = 3,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT                          = 4,
    VK_ACCESS_SHADER_READ_BIT                                    = 5,
    VK_ACCESS_SHADER_WRITE_BIT                                   = 6,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT                          = 7,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT                         = 8,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT                  = 9,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT                 = 10,
    VK_ACCESS_TRANSFER_READ_BIT                                  = 11,
    VK_ACCESS_TRANSFER_WRITE_BIT                                 = 12,
    VK_ACCESS_HOST_READ_BIT                                      = 13,
    VK_ACCESS_HOST_WRITE_BIT                                     = 14,
    VK_ACCESS_MEMORY_READ_BIT                                    = 15,
    VK_ACCESS_MEMORY_WRITE_BIT                                   = 16,
    VK_ACCESS_MAX_BIT                                            = 31
  );
  TVkAccessFlagBits = set of TVkAccessFlagBit;

  TVkDependencyFlagBit = (
    VK_DEPENDENCY_BY_REGION_BIT                                  = 0,
    VK_DEPENDENCY_BY_REGION_BITMAX_BIT                           = 31
  );
  TVkDependencyFlagBits = set of TVkDependencyFlagBit;

  TVkCommandPoolCreateFlagBit = (
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT                         = 0,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT              = 1,
    VK_COMMAND_POOL_CREATE_MAX_BIT                               = 31
  );
  TVkCommandPoolCreateFlagBits = set of TVkCommandPoolCreateFlagBit;

  TVkCommandPoolResetFlagBit = (
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT                  = 0,
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BITMAX_BIT           = 31
  );
  TVkCommandPoolResetFlagBits = set of TVkCommandPoolResetFlagBit;

  TVkCommandBufferLevel = (
    VK_COMMAND_BUFFER_LEVEL_PRIMARY                              = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY                            = 1,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM                             = $7FFFFFFF
  );
  PVkCommandBufferLevel = ^TVkCommandBufferLevel;
  PPVkCommandBufferLevel = ^PVkCommandBufferLevel;

  TVkCommandBufferUsageFlagBit = (
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT                  = 0,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT             = 1,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT                 = 2,
    VK_COMMAND_BUFFER_USAGE_MAX_BIT                              = 31
  );
  TVkCommandBufferUsageFlagBits = set of TVkCommandBufferUsageFlagBit;

  TVkQueryControlFlagBit = (
    VK_QUERY_CONTROL_PRECISE_BIT                                 = 0,
    VK_QUERY_CONTROL_PRECISE_BITMAX_BIT                          = 31
  );
  TVkQueryControlFlagBits = set of TVkQueryControlFlagBit;

  TVkCommandBufferResetFlagBit = (
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT                = 0,
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BITMAX_BIT         = 31
  );
  TVkCommandBufferResetFlagBits = set of TVkCommandBufferResetFlagBit;

  TVkStencilFaceFlagBit = (
    VK_STENCIL_FACE_FRONT_BIT                                    = 0,
    VK_STENCIL_FACE_BACK_BIT                                     = 1,
    VK_STENCIL_FMAX_BIT                                          = 31
  );
  TVkStencilFaceFlagBits = set of TVkStencilFaceFlagBit;

  TVkIndexType = (
    VK_INDEX_TYPE_UINT16                                         = 0,
    VK_INDEX_TYPE_UINT32                                         = 1,
    VK_INDEX_TYPE_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkIndexType = ^TVkIndexType;
  PPVkIndexType = ^PVkIndexType;

  TVkSubpassContents = (
    VK_SUBPASS_CONTENTS_INLINE                                   = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS                = 1,
    VK_SUBPASS_CONTENTS_MAX_ENUM                                 = $7FFFFFFF
  );
  PVkSubpassContents = ^TVkSubpassContents;
  PPVkSubpassContents = ^PVkSubpassContents;

{ ========================================== VK_KHR_surface ========================================== }
  TVkSurfaceTransformFlagBitKHR = (
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR                        = 0,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR                       = 1,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR                      = 2,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR                      = 3,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR               = 4,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR     = 5,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR    = 6,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR    = 7,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                         = 8,
    VK_SURFACE_TRANSFORM_MAX_BIT                                 = 31
  );
  TVkSurfaceTransformFlagBitsKHR = set of TVkSurfaceTransformFlagBitKHR;

  TVkCompositeAlphaFlagBitKHR = (
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR                            = 0,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR                    = 1,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR                   = 2,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR                           = 3,
    VK_COMPOSITE_ALPHA_MAX_BIT                                   = 31
  );
  TVkCompositeAlphaFlagBitsKHR = set of TVkCompositeAlphaFlagBitKHR;

  TVkColorSpaceKHR = (
    VK_COLORSPACE_SRGB_NONLINEAR_KHR                             = 0,
    VK_COLORSPACE_MAX_ENUM                                       = $7FFFFFFF
  );
  PVkColorSpaceKHR = ^TVkColorSpaceKHR;
  PPVkColorSpaceKHR = ^PVkColorSpaceKHR;

  TVkPresentModeKHR = (
    VK_PRESENT_MODE_IMMEDIATE_KHR                                = 0,
    VK_PRESENT_MODE_MAILBOX_KHR                                  = 1,
    VK_PRESENT_MODE_FIFO_KHR                                     = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR                             = 3,
    VK_PRESENT_MODE_MAX_ENUM                                     = $7FFFFFFF
  );
  PVkPresentModeKHR = ^TVkPresentModeKHR;
  PPVkPresentModeKHR = ^PVkPresentModeKHR;

{ ========================================== VK_KHR_display ========================================== }
  TVkDisplayPlaneAlphaFlagBitKHR = (
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR                        = 0,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR                        = 1,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR                     = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR       = 3,
    VK_DISPLAY_PLANE_ALPHA_MAX_BIT                               = 31
  );
  TVkDisplayPlaneAlphaFlagBitsKHR = set of TVkDisplayPlaneAlphaFlagBitKHR;

{ ======================================= VK_EXT_debug_report ======================================== }
  TVkDebugReportObjectTypeEXT = (
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT                      = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT                     = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT              = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT                       = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT                        = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT                    = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT               = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT                        = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT                = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT                       = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT                        = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT                        = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT                   = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT                  = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT                   = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT                = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT               = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT              = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT                  = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT                     = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT        = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT                      = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT              = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT               = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT                  = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT                 = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT                  = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT                = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT                 = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE__MAX_ENUM                        = $7FFFFFFF
  );
  PVkDebugReportObjectTypeEXT = ^TVkDebugReportObjectTypeEXT;
  PPVkDebugReportObjectTypeEXT = ^PVkDebugReportObjectTypeEXT;

  TVkDebugReportErrorEXT = (
    VK_DEBUG_REPORT_ERROR_NONE_EXT                               = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT                       = 1,
    VK_DEBUG_REPORT_ERROR__MAX_ENUM                              = $7FFFFFFF
  );
  PVkDebugReportErrorEXT = ^TVkDebugReportErrorEXT;
  PPVkDebugReportErrorEXT = ^PVkDebugReportErrorEXT;

  TVkDebugReportFlagBitEXT = (
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT                          = 0,
    VK_DEBUG_REPORT_WARNING_BIT_EXT                              = 1,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT                  = 2,
    VK_DEBUG_REPORT_ERROR_BIT_EXT                                = 3,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT                                = 4,
    VK_DEBUG_REPORT_MAX_BIT                                      = 31
  );
  TVkDebugReportFlagBitsEXT = set of TVkDebugReportFlagBitEXT;

type { simple types }

{ ========================================== VK_VERSION_1_0 ========================================== }
  VkFlags                                                        = VkUint32;
  PVkFlags                                                       = ^VkFlags;
  PPVkFlags                                                      = ^PVkFlags;

  VkInstanceCreateFlags                                          = VkFlags;
  PVkInstanceCreateFlags                                         = ^VkInstanceCreateFlags;
  PPVkInstanceCreateFlags                                        = ^PVkInstanceCreateFlags;

  _VkInstance                                                    = record end;
  VkInstance                                                     = ^_VkInstance;
  PVkInstance                                                    = ^VkInstance;
  PPVkInstance                                                   = ^PVkInstance;

  _VkPhysicalDevice                                              = record end;
  VkPhysicalDevice                                               = ^_VkPhysicalDevice;
  PVkPhysicalDevice                                              = ^VkPhysicalDevice;
  PPVkPhysicalDevice                                             = ^PVkPhysicalDevice;

  VkBool32                                                       = VkUint32;
  PVkBool32                                                      = ^VkBool32;
  PPVkBool32                                                     = ^PVkBool32;

  VkFormatFeatureFlags                                           = TVkFormatFeatureFlagBits;
  PVkFormatFeatureFlags                                          = ^VkFormatFeatureFlags;
  PPVkFormatFeatureFlags                                         = ^PVkFormatFeatureFlags;

  VkImageUsageFlags                                              = TVkImageUsageFlagBits;
  PVkImageUsageFlags                                             = ^VkImageUsageFlags;
  PPVkImageUsageFlags                                            = ^PVkImageUsageFlags;

  VkImageCreateFlags                                             = TVkImageCreateFlagBits;
  PVkImageCreateFlags                                            = ^VkImageCreateFlags;
  PPVkImageCreateFlags                                           = ^PVkImageCreateFlags;

  VkSampleCountFlags                                             = TVkSampleCountFlagBits;
  PVkSampleCountFlags                                            = ^VkSampleCountFlags;
  PPVkSampleCountFlags                                           = ^PVkSampleCountFlags;

  VkDeviceSize                                                   = VkUint64;
  PVkDeviceSize                                                  = ^VkDeviceSize;
  PPVkDeviceSize                                                 = ^PVkDeviceSize;

  VkQueueFlags                                                   = TVkQueueFlagBits;
  PVkQueueFlags                                                  = ^VkQueueFlags;
  PPVkQueueFlags                                                 = ^PVkQueueFlags;

  VkMemoryPropertyFlags                                          = TVkMemoryPropertyFlagBits;
  PVkMemoryPropertyFlags                                         = ^VkMemoryPropertyFlags;
  PPVkMemoryPropertyFlags                                        = ^PVkMemoryPropertyFlags;

  VkMemoryHeapFlags                                              = TVkMemoryHeapFlagBits;
  PVkMemoryHeapFlags                                             = ^VkMemoryHeapFlags;
  PPVkMemoryHeapFlags                                            = ^PVkMemoryHeapFlags;

  _VkDevice                                                      = record end;
  VkDevice                                                       = ^_VkDevice;
  PVkDevice                                                      = ^VkDevice;
  PPVkDevice                                                     = ^PVkDevice;

  VkDeviceCreateFlags                                            = VkFlags;
  PVkDeviceCreateFlags                                           = ^VkDeviceCreateFlags;
  PPVkDeviceCreateFlags                                          = ^PVkDeviceCreateFlags;

  VkDeviceQueueCreateFlags                                       = VkFlags;
  PVkDeviceQueueCreateFlags                                      = ^VkDeviceQueueCreateFlags;
  PPVkDeviceQueueCreateFlags                                     = ^PVkDeviceQueueCreateFlags;

  _VkQueue                                                       = record end;
  VkQueue                                                        = ^_VkQueue;
  PVkQueue                                                       = ^VkQueue;
  PPVkQueue                                                      = ^PVkQueue;

  _VkSemaphore                                                   = record end;
  VkSemaphore                                                    = {$IFDEF VK_CPU64}^_VkSemaphore{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkSemaphore                                                   = ^VkSemaphore;
  PPVkSemaphore                                                  = ^PVkSemaphore;

  VkPipelineStageFlags                                           = TVkPipelineStageFlagBits;
  PVkPipelineStageFlags                                          = ^VkPipelineStageFlags;
  PPVkPipelineStageFlags                                         = ^PVkPipelineStageFlags;

  _VkCommandPool                                                 = record end;
  VkCommandPool                                                  = {$IFDEF VK_CPU64}^_VkCommandPool{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkCommandPool                                                 = ^VkCommandPool;
  PPVkCommandPool                                                = ^PVkCommandPool;

  _VkCommandBuffer                                               = record end;
  VkCommandBuffer                                                = ^_VkCommandBuffer;
  PVkCommandBuffer                                               = ^VkCommandBuffer;
  PPVkCommandBuffer                                              = ^PVkCommandBuffer;

  _VkFence                                                       = record end;
  VkFence                                                        = {$IFDEF VK_CPU64}^_VkFence{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkFence                                                       = ^VkFence;
  PPVkFence                                                      = ^PVkFence;

  _VkDeviceMemory                                                = record end;
  VkDeviceMemory                                                 = {$IFDEF VK_CPU64}^_VkDeviceMemory{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDeviceMemory                                                = ^VkDeviceMemory;
  PPVkDeviceMemory                                               = ^PVkDeviceMemory;

  VkMemoryMapFlags                                               = VkFlags;
  PVkMemoryMapFlags                                              = ^VkMemoryMapFlags;
  PPVkMemoryMapFlags                                             = ^PVkMemoryMapFlags;

  _VkBuffer                                                      = record end;
  VkBuffer                                                       = {$IFDEF VK_CPU64}^_VkBuffer{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkBuffer                                                      = ^VkBuffer;
  PPVkBuffer                                                     = ^PVkBuffer;

  _VkImage                                                       = record end;
  VkImage                                                        = {$IFDEF VK_CPU64}^_VkImage{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkImage                                                       = ^VkImage;
  PPVkImage                                                      = ^PVkImage;

  VkImageAspectFlags                                             = TVkImageAspectFlagBits;
  PVkImageAspectFlags                                            = ^VkImageAspectFlags;
  PPVkImageAspectFlags                                           = ^PVkImageAspectFlags;

  VkSparseImageFormatFlags                                       = TVkSparseImageFormatFlagBits;
  PVkSparseImageFormatFlags                                      = ^VkSparseImageFormatFlags;
  PPVkSparseImageFormatFlags                                     = ^PVkSparseImageFormatFlags;

  VkSparseMemoryBindFlags                                        = TVkSparseMemoryBindFlagBits;
  PVkSparseMemoryBindFlags                                       = ^VkSparseMemoryBindFlags;
  PPVkSparseMemoryBindFlags                                      = ^PVkSparseMemoryBindFlags;

  VkFenceCreateFlags                                             = TVkFenceCreateFlagBits;
  PVkFenceCreateFlags                                            = ^VkFenceCreateFlags;
  PPVkFenceCreateFlags                                           = ^PVkFenceCreateFlags;

  VkSemaphoreCreateFlags                                         = VkFlags;
  PVkSemaphoreCreateFlags                                        = ^VkSemaphoreCreateFlags;
  PPVkSemaphoreCreateFlags                                       = ^PVkSemaphoreCreateFlags;

  VkEventCreateFlags                                             = VkFlags;
  PVkEventCreateFlags                                            = ^VkEventCreateFlags;
  PPVkEventCreateFlags                                           = ^PVkEventCreateFlags;

  _VkEvent                                                       = record end;
  VkEvent                                                        = {$IFDEF VK_CPU64}^_VkEvent{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkEvent                                                       = ^VkEvent;
  PPVkEvent                                                      = ^PVkEvent;

  VkQueryPoolCreateFlags                                         = VkFlags;
  PVkQueryPoolCreateFlags                                        = ^VkQueryPoolCreateFlags;
  PPVkQueryPoolCreateFlags                                       = ^PVkQueryPoolCreateFlags;

  VkQueryPipelineStatisticFlags                                  = TVkQueryPipelineStatisticFlagBits;
  PVkQueryPipelineStatisticFlags                                 = ^VkQueryPipelineStatisticFlags;
  PPVkQueryPipelineStatisticFlags                                = ^PVkQueryPipelineStatisticFlags;

  _VkQueryPool                                                   = record end;
  VkQueryPool                                                    = {$IFDEF VK_CPU64}^_VkQueryPool{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkQueryPool                                                   = ^VkQueryPool;
  PPVkQueryPool                                                  = ^PVkQueryPool;

  VkQueryResultFlags                                             = TVkQueryResultFlagBits;
  PVkQueryResultFlags                                            = ^VkQueryResultFlags;
  PPVkQueryResultFlags                                           = ^PVkQueryResultFlags;

  VkBufferCreateFlags                                            = TVkBufferCreateFlagBits;
  PVkBufferCreateFlags                                           = ^VkBufferCreateFlags;
  PPVkBufferCreateFlags                                          = ^PVkBufferCreateFlags;

  VkBufferUsageFlags                                             = TVkBufferUsageFlagBits;
  PVkBufferUsageFlags                                            = ^VkBufferUsageFlags;
  PPVkBufferUsageFlags                                           = ^PVkBufferUsageFlags;

  VkBufferViewCreateFlags                                        = VkFlags;
  PVkBufferViewCreateFlags                                       = ^VkBufferViewCreateFlags;
  PPVkBufferViewCreateFlags                                      = ^PVkBufferViewCreateFlags;

  _VkBufferView                                                  = record end;
  VkBufferView                                                   = {$IFDEF VK_CPU64}^_VkBufferView{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkBufferView                                                  = ^VkBufferView;
  PPVkBufferView                                                 = ^PVkBufferView;

  VkImageViewCreateFlags                                         = VkFlags;
  PVkImageViewCreateFlags                                        = ^VkImageViewCreateFlags;
  PPVkImageViewCreateFlags                                       = ^PVkImageViewCreateFlags;

  _VkImageView                                                   = record end;
  VkImageView                                                    = {$IFDEF VK_CPU64}^_VkImageView{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkImageView                                                   = ^VkImageView;
  PPVkImageView                                                  = ^PVkImageView;

  VkShaderModuleCreateFlags                                      = VkFlags;
  PVkShaderModuleCreateFlags                                     = ^VkShaderModuleCreateFlags;
  PPVkShaderModuleCreateFlags                                    = ^PVkShaderModuleCreateFlags;

  _VkShaderModule                                                = record end;
  VkShaderModule                                                 = {$IFDEF VK_CPU64}^_VkShaderModule{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkShaderModule                                                = ^VkShaderModule;
  PPVkShaderModule                                               = ^PVkShaderModule;

  VkPipelineCacheCreateFlags                                     = VkFlags;
  PVkPipelineCacheCreateFlags                                    = ^VkPipelineCacheCreateFlags;
  PPVkPipelineCacheCreateFlags                                   = ^PVkPipelineCacheCreateFlags;

  _VkPipelineCache                                               = record end;
  VkPipelineCache                                                = {$IFDEF VK_CPU64}^_VkPipelineCache{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkPipelineCache                                               = ^VkPipelineCache;
  PPVkPipelineCache                                              = ^PVkPipelineCache;

  VkPipelineCreateFlags                                          = TVkPipelineCreateFlagBits;
  PVkPipelineCreateFlags                                         = ^VkPipelineCreateFlags;
  PPVkPipelineCreateFlags                                        = ^PVkPipelineCreateFlags;

  VkPipelineShaderStageCreateFlags                               = VkFlags;
  PVkPipelineShaderStageCreateFlags                              = ^VkPipelineShaderStageCreateFlags;
  PPVkPipelineShaderStageCreateFlags                             = ^PVkPipelineShaderStageCreateFlags;

  VkPipelineVertexInputStateCreateFlags                          = VkFlags;
  PVkPipelineVertexInputStateCreateFlags                         = ^VkPipelineVertexInputStateCreateFlags;
  PPVkPipelineVertexInputStateCreateFlags                        = ^PVkPipelineVertexInputStateCreateFlags;

  VkPipelineInputAssemblyStateCreateFlags                        = VkFlags;
  PVkPipelineInputAssemblyStateCreateFlags                       = ^VkPipelineInputAssemblyStateCreateFlags;
  PPVkPipelineInputAssemblyStateCreateFlags                      = ^PVkPipelineInputAssemblyStateCreateFlags;

  VkPipelineTessellationStateCreateFlags                         = VkFlags;
  PVkPipelineTessellationStateCreateFlags                        = ^VkPipelineTessellationStateCreateFlags;
  PPVkPipelineTessellationStateCreateFlags                       = ^PVkPipelineTessellationStateCreateFlags;

  VkPipelineViewportStateCreateFlags                             = VkFlags;
  PVkPipelineViewportStateCreateFlags                            = ^VkPipelineViewportStateCreateFlags;
  PPVkPipelineViewportStateCreateFlags                           = ^PVkPipelineViewportStateCreateFlags;

  VkPipelineRasterizationStateCreateFlags                        = VkFlags;
  PVkPipelineRasterizationStateCreateFlags                       = ^VkPipelineRasterizationStateCreateFlags;
  PPVkPipelineRasterizationStateCreateFlags                      = ^PVkPipelineRasterizationStateCreateFlags;

  VkCullModeFlags                                                = TVkCullModeFlagBits;
  PVkCullModeFlags                                               = ^VkCullModeFlags;
  PPVkCullModeFlags                                              = ^PVkCullModeFlags;

  VkPipelineMultisampleStateCreateFlags                          = VkFlags;
  PVkPipelineMultisampleStateCreateFlags                         = ^VkPipelineMultisampleStateCreateFlags;
  PPVkPipelineMultisampleStateCreateFlags                        = ^PVkPipelineMultisampleStateCreateFlags;

  VkSampleMask                                                   = VkUint32;
  PVkSampleMask                                                  = ^VkSampleMask;
  PPVkSampleMask                                                 = ^PVkSampleMask;

  VkPipelineDepthStencilStateCreateFlags                         = VkFlags;
  PVkPipelineDepthStencilStateCreateFlags                        = ^VkPipelineDepthStencilStateCreateFlags;
  PPVkPipelineDepthStencilStateCreateFlags                       = ^PVkPipelineDepthStencilStateCreateFlags;

  VkPipelineColorBlendStateCreateFlags                           = VkFlags;
  PVkPipelineColorBlendStateCreateFlags                          = ^VkPipelineColorBlendStateCreateFlags;
  PPVkPipelineColorBlendStateCreateFlags                         = ^PVkPipelineColorBlendStateCreateFlags;

  VkColorComponentFlags                                          = TVkColorComponentFlagBits;
  PVkColorComponentFlags                                         = ^VkColorComponentFlags;
  PPVkColorComponentFlags                                        = ^PVkColorComponentFlags;

  VkPipelineDynamicStateCreateFlags                              = VkFlags;
  PVkPipelineDynamicStateCreateFlags                             = ^VkPipelineDynamicStateCreateFlags;
  PPVkPipelineDynamicStateCreateFlags                            = ^PVkPipelineDynamicStateCreateFlags;

  _VkPipelineLayout                                              = record end;
  VkPipelineLayout                                               = {$IFDEF VK_CPU64}^_VkPipelineLayout{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkPipelineLayout                                              = ^VkPipelineLayout;
  PPVkPipelineLayout                                             = ^PVkPipelineLayout;

  _VkRenderPass                                                  = record end;
  VkRenderPass                                                   = {$IFDEF VK_CPU64}^_VkRenderPass{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkRenderPass                                                  = ^VkRenderPass;
  PPVkRenderPass                                                 = ^PVkRenderPass;

  _VkPipeline                                                    = record end;
  VkPipeline                                                     = {$IFDEF VK_CPU64}^_VkPipeline{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkPipeline                                                    = ^VkPipeline;
  PPVkPipeline                                                   = ^PVkPipeline;

  VkPipelineLayoutCreateFlags                                    = VkFlags;
  PVkPipelineLayoutCreateFlags                                   = ^VkPipelineLayoutCreateFlags;
  PPVkPipelineLayoutCreateFlags                                  = ^PVkPipelineLayoutCreateFlags;

  _VkDescriptorSetLayout                                         = record end;
  VkDescriptorSetLayout                                          = {$IFDEF VK_CPU64}^_VkDescriptorSetLayout{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDescriptorSetLayout                                         = ^VkDescriptorSetLayout;
  PPVkDescriptorSetLayout                                        = ^PVkDescriptorSetLayout;

  VkShaderStageFlags                                             = TVkShaderStageFlagBits;
  PVkShaderStageFlags                                            = ^VkShaderStageFlags;
  PPVkShaderStageFlags                                           = ^PVkShaderStageFlags;

  VkSamplerCreateFlags                                           = VkFlags;
  PVkSamplerCreateFlags                                          = ^VkSamplerCreateFlags;
  PPVkSamplerCreateFlags                                         = ^PVkSamplerCreateFlags;

  _VkSampler                                                     = record end;
  VkSampler                                                      = {$IFDEF VK_CPU64}^_VkSampler{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkSampler                                                     = ^VkSampler;
  PPVkSampler                                                    = ^PVkSampler;

  VkDescriptorSetLayoutCreateFlags                               = VkFlags;
  PVkDescriptorSetLayoutCreateFlags                              = ^VkDescriptorSetLayoutCreateFlags;
  PPVkDescriptorSetLayoutCreateFlags                             = ^PVkDescriptorSetLayoutCreateFlags;

  VkDescriptorPoolCreateFlags                                    = TVkDescriptorPoolCreateFlagBits;
  PVkDescriptorPoolCreateFlags                                   = ^VkDescriptorPoolCreateFlags;
  PPVkDescriptorPoolCreateFlags                                  = ^PVkDescriptorPoolCreateFlags;

  _VkDescriptorPool                                              = record end;
  VkDescriptorPool                                               = {$IFDEF VK_CPU64}^_VkDescriptorPool{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDescriptorPool                                              = ^VkDescriptorPool;
  PPVkDescriptorPool                                             = ^PVkDescriptorPool;

  VkDescriptorPoolResetFlags                                     = VkFlags;
  PVkDescriptorPoolResetFlags                                    = ^VkDescriptorPoolResetFlags;
  PPVkDescriptorPoolResetFlags                                   = ^PVkDescriptorPoolResetFlags;

  _VkDescriptorSet                                               = record end;
  VkDescriptorSet                                                = {$IFDEF VK_CPU64}^_VkDescriptorSet{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDescriptorSet                                               = ^VkDescriptorSet;
  PPVkDescriptorSet                                              = ^PVkDescriptorSet;

  VkFramebufferCreateFlags                                       = VkFlags;
  PVkFramebufferCreateFlags                                      = ^VkFramebufferCreateFlags;
  PPVkFramebufferCreateFlags                                     = ^PVkFramebufferCreateFlags;

  _VkFramebuffer                                                 = record end;
  VkFramebuffer                                                  = {$IFDEF VK_CPU64}^_VkFramebuffer{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkFramebuffer                                                 = ^VkFramebuffer;
  PPVkFramebuffer                                                = ^PVkFramebuffer;

  VkRenderPassCreateFlags                                        = VkFlags;
  PVkRenderPassCreateFlags                                       = ^VkRenderPassCreateFlags;
  PPVkRenderPassCreateFlags                                      = ^PVkRenderPassCreateFlags;

  VkAttachmentDescriptionFlags                                   = TVkAttachmentDescriptionFlagBits;
  PVkAttachmentDescriptionFlags                                  = ^VkAttachmentDescriptionFlags;
  PPVkAttachmentDescriptionFlags                                 = ^PVkAttachmentDescriptionFlags;

  VkSubpassDescriptionFlags                                      = VkFlags;
  PVkSubpassDescriptionFlags                                     = ^VkSubpassDescriptionFlags;
  PPVkSubpassDescriptionFlags                                    = ^PVkSubpassDescriptionFlags;

  VkAccessFlags                                                  = TVkAccessFlagBits;
  PVkAccessFlags                                                 = ^VkAccessFlags;
  PPVkAccessFlags                                                = ^PVkAccessFlags;

  VkDependencyFlags                                              = TVkDependencyFlagBits;
  PVkDependencyFlags                                             = ^VkDependencyFlags;
  PPVkDependencyFlags                                            = ^PVkDependencyFlags;

  VkCommandPoolCreateFlags                                       = TVkCommandPoolCreateFlagBits;
  PVkCommandPoolCreateFlags                                      = ^VkCommandPoolCreateFlags;
  PPVkCommandPoolCreateFlags                                     = ^PVkCommandPoolCreateFlags;

  VkCommandPoolResetFlags                                        = TVkCommandPoolResetFlagBits;
  PVkCommandPoolResetFlags                                       = ^VkCommandPoolResetFlags;
  PPVkCommandPoolResetFlags                                      = ^PVkCommandPoolResetFlags;

  VkCommandBufferUsageFlags                                      = TVkCommandBufferUsageFlagBits;
  PVkCommandBufferUsageFlags                                     = ^VkCommandBufferUsageFlags;
  PPVkCommandBufferUsageFlags                                    = ^PVkCommandBufferUsageFlags;

  VkQueryControlFlags                                            = TVkQueryControlFlagBits;
  PVkQueryControlFlags                                           = ^VkQueryControlFlags;
  PPVkQueryControlFlags                                          = ^PVkQueryControlFlags;

  VkCommandBufferResetFlags                                      = TVkCommandBufferResetFlagBits;
  PVkCommandBufferResetFlags                                     = ^VkCommandBufferResetFlags;
  PPVkCommandBufferResetFlags                                    = ^PVkCommandBufferResetFlags;

  VkStencilFaceFlags                                             = TVkStencilFaceFlagBits;
  PVkStencilFaceFlags                                            = ^VkStencilFaceFlags;
  PPVkStencilFaceFlags                                           = ^PVkStencilFaceFlags;

{ ========================================== VK_KHR_surface ========================================== }
  _VkSurfaceKHR                                                  = record end;
  VkSurfaceKHR                                                   = {$IFDEF VK_CPU64}^_VkSurfaceKHR{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkSurfaceKHR                                                  = ^VkSurfaceKHR;
  PPVkSurfaceKHR                                                 = ^PVkSurfaceKHR;

  VkSurfaceTransformFlagsKHR                                     = TVkSurfaceTransformFlagBitsKHR;
  PVkSurfaceTransformFlagsKHR                                    = ^VkSurfaceTransformFlagsKHR;
  PPVkSurfaceTransformFlagsKHR                                   = ^PVkSurfaceTransformFlagsKHR;

  VkCompositeAlphaFlagsKHR                                       = TVkCompositeAlphaFlagBitsKHR;
  PVkCompositeAlphaFlagsKHR                                      = ^VkCompositeAlphaFlagsKHR;
  PPVkCompositeAlphaFlagsKHR                                     = ^PVkCompositeAlphaFlagsKHR;

{ ========================================= VK_KHR_swapchain ========================================= }
  VkSwapchainCreateFlagsKHR                                      = VkFlags;
  PVkSwapchainCreateFlagsKHR                                     = ^VkSwapchainCreateFlagsKHR;
  PPVkSwapchainCreateFlagsKHR                                    = ^PVkSwapchainCreateFlagsKHR;

  _VkSwapchainKHR                                                = record end;
  VkSwapchainKHR                                                 = {$IFDEF VK_CPU64}^_VkSwapchainKHR{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkSwapchainKHR                                                = ^VkSwapchainKHR;
  PPVkSwapchainKHR                                               = ^PVkSwapchainKHR;

{ ========================================== VK_KHR_display ========================================== }
  _VkDisplayKHR                                                  = record end;
  VkDisplayKHR                                                   = {$IFDEF VK_CPU64}^_VkDisplayKHR{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDisplayKHR                                                  = ^VkDisplayKHR;
  PPVkDisplayKHR                                                 = ^PVkDisplayKHR;

  _VkDisplayModeKHR                                              = record end;
  VkDisplayModeKHR                                               = {$IFDEF VK_CPU64}^_VkDisplayModeKHR{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDisplayModeKHR                                              = ^VkDisplayModeKHR;
  PPVkDisplayModeKHR                                             = ^PVkDisplayModeKHR;

  VkDisplayModeCreateFlagsKHR                                    = VkFlags;
  PVkDisplayModeCreateFlagsKHR                                   = ^VkDisplayModeCreateFlagsKHR;
  PPVkDisplayModeCreateFlagsKHR                                  = ^PVkDisplayModeCreateFlagsKHR;

  VkDisplayPlaneAlphaFlagsKHR                                    = TVkDisplayPlaneAlphaFlagBitsKHR;
  PVkDisplayPlaneAlphaFlagsKHR                                   = ^VkDisplayPlaneAlphaFlagsKHR;
  PPVkDisplayPlaneAlphaFlagsKHR                                  = ^PVkDisplayPlaneAlphaFlagsKHR;

  VkDisplaySurfaceCreateFlagsKHR                                 = VkFlags;
  PVkDisplaySurfaceCreateFlagsKHR                                = ^VkDisplaySurfaceCreateFlagsKHR;
  PPVkDisplaySurfaceCreateFlagsKHR                               = ^PVkDisplaySurfaceCreateFlagsKHR;

{ ======================================= VK_KHR_xlib_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  VkXlibSurfaceCreateFlagsKHR                                    = VkFlags;
  PVkXlibSurfaceCreateFlagsKHR                                   = ^VkXlibSurfaceCreateFlagsKHR;
  PPVkXlibSurfaceCreateFlagsKHR                                  = ^PVkXlibSurfaceCreateFlagsKHR;
{$ENDIF}

{ ======================================== VK_KHR_xcb_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  VkXcbSurfaceCreateFlagsKHR                                     = VkFlags;
  PVkXcbSurfaceCreateFlagsKHR                                    = ^VkXcbSurfaceCreateFlagsKHR;
  PPVkXcbSurfaceCreateFlagsKHR                                   = ^PVkXcbSurfaceCreateFlagsKHR;
{$ENDIF}

{ ====================================== VK_KHR_wayland_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  VkWaylandSurfaceCreateFlagsKHR                                 = VkFlags;
  PVkWaylandSurfaceCreateFlagsKHR                                = ^VkWaylandSurfaceCreateFlagsKHR;
  PPVkWaylandSurfaceCreateFlagsKHR                               = ^PVkWaylandSurfaceCreateFlagsKHR;
{$ENDIF}

{ ======================================== VK_KHR_mir_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  VkMirSurfaceCreateFlagsKHR                                     = VkFlags;
  PVkMirSurfaceCreateFlagsKHR                                    = ^VkMirSurfaceCreateFlagsKHR;
  PPVkMirSurfaceCreateFlagsKHR                                   = ^PVkMirSurfaceCreateFlagsKHR;
{$ENDIF}

{ ====================================== VK_KHR_android_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidSurfaceCreateFlagsKHR                                 = VkFlags;
  PVkAndroidSurfaceCreateFlagsKHR                                = ^VkAndroidSurfaceCreateFlagsKHR;
  PPVkAndroidSurfaceCreateFlagsKHR                               = ^PVkAndroidSurfaceCreateFlagsKHR;
{$ENDIF}

{ ======================================= VK_KHR_win32_surface ======================================= }
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  VkWin32SurfaceCreateFlagsKHR                                   = VkFlags;
  PVkWin32SurfaceCreateFlagsKHR                                  = ^VkWin32SurfaceCreateFlagsKHR;
  PPVkWin32SurfaceCreateFlagsKHR                                 = ^PVkWin32SurfaceCreateFlagsKHR;
{$ENDIF}

{ ======================================= VK_EXT_debug_report ======================================== }
  VkDebugReportFlagsEXT                                          = TVkDebugReportFlagBitsEXT;
  PVkDebugReportFlagsEXT                                         = ^VkDebugReportFlagsEXT;
  PPVkDebugReportFlagsEXT                                        = ^PVkDebugReportFlagsEXT;

  _VkDebugReportCallbackEXT                                      = record end;
  VkDebugReportCallbackEXT                                       = {$IFDEF VK_CPU64}^_VkDebugReportCallbackEXT{$ELSE}VkNonDispatchableHandle{$ENDIF};
  PVkDebugReportCallbackEXT                                      = ^VkDebugReportCallbackEXT;
  PPVkDebugReportCallbackEXT                                     = ^PVkDebugReportCallbackEXT;

type { function pointers }

{ ========================================== VK_VERSION_1_0 ========================================== }
  TvkAllocationFunction = function (
          pUserData:                    PVkVoid; 
          size:                         VkSize; 
          alignment:                    VkSize; 
          allocationScope:              TVkSystemAllocationScope
  ): PVkVoid; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkReallocationFunction = function (
          pUserData:                    PVkVoid; 
          pOriginal:                    PVkVoid; 
          size:                         VkSize; 
          alignment:                    VkSize; 
          allocationScope:              TVkSystemAllocationScope
  ): PVkVoid; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeFunction = procedure(
          pUserData:                    PVkVoid; 
          pMemory:                      PVkVoid
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInternalAllocationNotification = procedure(
          pUserData:                    PVkVoid; 
          size:                         VkSize; 
          allocationType:               TVkInternalAllocationType; 
          allocationScope:              TVkSystemAllocationScope
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInternalFreeNotification = procedure(
          pUserData:                    PVkVoid; 
          size:                         VkSize; 
          allocationType:               TVkInternalAllocationType; 
          allocationScope:              TVkSystemAllocationScope
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkVoidFunction = procedure(
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ======================================= VK_EXT_debug_report ======================================== }
  TvkDebugReportCallbackEXT = function (
          flags:                        VkDebugReportFlagsEXT; 
          objectType:                   TVkDebugReportObjectTypeEXT; 
          uObject:                      VkUint64; 
          location:                     VkSize; 
          messageCode:                  VkInt32; 
          pLayerPrefix:                 PVkChar; 
          pMessage:                     PVkChar; 
          pUserData:                    PVkVoid
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

type { structures }

{ ========================================== VK_VERSION_1_0 ========================================== }
  TVkApplicationInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    pApplicationName:                                 PVkChar;
    applicationVersion:                               VkUint32;
    pEngineName:                                      PVkChar;
    engineVersion:                                    VkUint32;
    apiVersion:                                       VkUint32;
  end;
  PVkApplicationInfo = ^TVkApplicationInfo;
  PPVkApplicationInfo = ^PVkApplicationInfo;

  TVkInstanceCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkInstanceCreateFlags;
    pApplicationInfo:                                 PVkApplicationInfo;
    enabledLayerCount:                                VkUint32;
    ppEnabledLayerNames:                              PPVkChar;
    enabledExtensionCount:                            VkUint32;
    ppEnabledExtensionNames:                          PPVkChar;
  end;
  PVkInstanceCreateInfo = ^TVkInstanceCreateInfo;
  PPVkInstanceCreateInfo = ^PVkInstanceCreateInfo;

  TVkAllocationCallbacks = record
    pUserData:                                        PVkVoid;
    pfnAllocation:                                    TvkAllocationFunction;
    pfnReallocation:                                  TvkReallocationFunction;
    pfnFree:                                          TvkFreeFunction;
    pfnInternalAllocation:                            TvkInternalAllocationNotification;
    pfnInternalFree:                                  TvkInternalFreeNotification;
  end;
  PVkAllocationCallbacks = ^TVkAllocationCallbacks;
  PPVkAllocationCallbacks = ^PVkAllocationCallbacks;

  TVkPhysicalDeviceFeatures = record
    robustBufferAccess:                               VkBool32;
    fullDrawIndexUint32:                              VkBool32;
    imageCubeArray:                                   VkBool32;
    independentBlend:                                 VkBool32;
    geometryShader:                                   VkBool32;
    tessellationShader:                               VkBool32;
    sampleRateShading:                                VkBool32;
    dualSrcBlend:                                     VkBool32;
    logicOp:                                          VkBool32;
    multiDrawIndirect:                                VkBool32;
    drawIndirectFirstInstance:                        VkBool32;
    depthClamp:                                       VkBool32;
    depthBiasClamp:                                   VkBool32;
    fillModeNonSolid:                                 VkBool32;
    depthBounds:                                      VkBool32;
    wideLines:                                        VkBool32;
    largePoints:                                      VkBool32;
    alphaToOne:                                       VkBool32;
    multiViewport:                                    VkBool32;
    samplerAnisotropy:                                VkBool32;
    textureCompressionETC2:                           VkBool32;
    textureCompressionASTC_LDR:                       VkBool32;
    textureCompressionBC:                             VkBool32;
    occlusionQueryPrecise:                            VkBool32;
    pipelineStatisticsQuery:                          VkBool32;
    vertexPipelineStoresAndAtomics:                   VkBool32;
    fragmentStoresAndAtomics:                         VkBool32;
    shaderTessellationAndGeometryPointSize:           VkBool32;
    shaderImageGatherExtended:                        VkBool32;
    shaderStorageImageExtendedFormats:                VkBool32;
    shaderStorageImageMultisample:                    VkBool32;
    shaderStorageImageReadWithoutFormat:              VkBool32;
    shaderStorageImageWriteWithoutFormat:             VkBool32;
    shaderUniformBufferArrayDynamicIndexing:          VkBool32;
    shaderSampledImageArrayDynamicIndexing:           VkBool32;
    shaderStorageBufferArrayDynamicIndexing:          VkBool32;
    shaderStorageImageArrayDynamicIndexing:           VkBool32;
    shaderClipDistance:                               VkBool32;
    shaderCullDistance:                               VkBool32;
    shaderFloat64:                                    VkBool32;
    shaderInt64:                                      VkBool32;
    shaderInt16:                                      VkBool32;
    shaderResourceResidency:                          VkBool32;
    shaderResourceMinLod:                             VkBool32;
    sparseBinding:                                    VkBool32;
    sparseResidencyBuffer:                            VkBool32;
    sparseResidencyImage2D:                           VkBool32;
    sparseResidencyImage3D:                           VkBool32;
    sparseResidency2Samples:                          VkBool32;
    sparseResidency4Samples:                          VkBool32;
    sparseResidency8Samples:                          VkBool32;
    sparseResidency16Samples:                         VkBool32;
    sparseResidencyAliased:                           VkBool32;
    variableMultisampleRate:                          VkBool32;
    inheritedQueries:                                 VkBool32;
  end;
  PVkPhysicalDeviceFeatures = ^TVkPhysicalDeviceFeatures;
  PPVkPhysicalDeviceFeatures = ^PVkPhysicalDeviceFeatures;

  TVkFormatProperties = record
    linearTilingFeatures:                             VkFormatFeatureFlags;
    optimalTilingFeatures:                            VkFormatFeatureFlags;
    bufferFeatures:                                   VkFormatFeatureFlags;
  end;
  PVkFormatProperties = ^TVkFormatProperties;
  PPVkFormatProperties = ^PVkFormatProperties;

  TVkExtent3D = record
    width:                                            VkUint32;
    height:                                           VkUint32;
    depth:                                            VkUint32;
  end;
  PVkExtent3D = ^TVkExtent3D;
  PPVkExtent3D = ^PVkExtent3D;

  TVkImageFormatProperties = record
    maxExtent:                                        TVkExtent3D;
    maxMipLevels:                                     VkUint32;
    maxArrayLayers:                                   VkUint32;
    sampleCounts:                                     VkSampleCountFlags;
    maxResourceSize:                                  VkDeviceSize;
  end;
  PVkImageFormatProperties = ^TVkImageFormatProperties;
  PPVkImageFormatProperties = ^PVkImageFormatProperties;

  TVkPhysicalDeviceLimits = record
    maxImageDimension1D:                              VkUint32;
    maxImageDimension2D:                              VkUint32;
    maxImageDimension3D:                              VkUint32;
    maxImageDimensionCube:                            VkUint32;
    maxImageArrayLayers:                              VkUint32;
    maxTexelBufferElements:                           VkUint32;
    maxUniformBufferRange:                            VkUint32;
    maxStorageBufferRange:                            VkUint32;
    maxPushConstantsSize:                             VkUint32;
    maxMemoryAllocationCount:                         VkUint32;
    maxSamplerAllocationCount:                        VkUint32;
    bufferImageGranularity:                           VkDeviceSize;
    sparseAddressSpaceSize:                           VkDeviceSize;
    maxBoundDescriptorSets:                           VkUint32;
    maxPerStageDescriptorSamplers:                    VkUint32;
    maxPerStageDescriptorUniformBuffers:              VkUint32;
    maxPerStageDescriptorStorageBuffers:              VkUint32;
    maxPerStageDescriptorSampledImages:               VkUint32;
    maxPerStageDescriptorStorageImages:               VkUint32;
    maxPerStageDescriptorInputAttachments:            VkUint32;
    maxPerStageResources:                             VkUint32;
    maxDescriptorSetSamplers:                         VkUint32;
    maxDescriptorSetUniformBuffers:                   VkUint32;
    maxDescriptorSetUniformBuffersDynamic:            VkUint32;
    maxDescriptorSetStorageBuffers:                   VkUint32;
    maxDescriptorSetStorageBuffersDynamic:            VkUint32;
    maxDescriptorSetSampledImages:                    VkUint32;
    maxDescriptorSetStorageImages:                    VkUint32;
    maxDescriptorSetInputAttachments:                 VkUint32;
    maxVertexInputAttributes:                         VkUint32;
    maxVertexInputBindings:                           VkUint32;
    maxVertexInputAttributeOffset:                    VkUint32;
    maxVertexInputBindingStride:                      VkUint32;
    maxVertexOutputComponents:                        VkUint32;
    maxTessellationGenerationLevel:                   VkUint32;
    maxTessellationPatchSize:                         VkUint32;
    maxTessellationControlPerVertexInputComponents:   VkUint32;
    maxTessellationControlPerVertexOutputComponents:  VkUint32;
    maxTessellationControlPerPatchOutputComponents:   VkUint32;
    maxTessellationControlTotalOutputComponents:      VkUint32;
    maxTessellationEvaluationInputComponents:         VkUint32;
    maxTessellationEvaluationOutputComponents:        VkUint32;
    maxGeometryShaderInvocations:                     VkUint32;
    maxGeometryInputComponents:                       VkUint32;
    maxGeometryOutputComponents:                      VkUint32;
    maxGeometryOutputVertices:                        VkUint32;
    maxGeometryTotalOutputComponents:                 VkUint32;
    maxFragmentInputComponents:                       VkUint32;
    maxFragmentOutputAttachments:                     VkUint32;
    maxFragmentDualSrcAttachments:                    VkUint32;
    maxFragmentCombinedOutputResources:               VkUint32;
    maxComputeSharedMemorySize:                       VkUint32;
    maxComputeWorkGroupCount:                         array[0..2] of VkUint32;
    maxComputeWorkGroupInvocations:                   VkUint32;
    maxComputeWorkGroupSize:                          array[0..2] of VkUint32;
    subPixelPrecisionBits:                            VkUint32;
    subTexelPrecisionBits:                            VkUint32;
    mipmapPrecisionBits:                              VkUint32;
    maxDrawIndexedIndexValue:                         VkUint32;
    maxDrawIndirectCount:                             VkUint32;
    maxSamplerLodBias:                                VkFloat;
    maxSamplerAnisotropy:                             VkFloat;
    maxViewports:                                     VkUint32;
    maxViewportDimensions:                            array[0..1] of VkUint32;
    viewportBoundsRange:                              array[0..1] of VkFloat;
    viewportSubPixelBits:                             VkUint32;
    minMemoryMapAlignment:                            VkSize;
    minTexelBufferOffsetAlignment:                    VkDeviceSize;
    minUniformBufferOffsetAlignment:                  VkDeviceSize;
    minStorageBufferOffsetAlignment:                  VkDeviceSize;
    minTexelOffset:                                   VkInt32;
    maxTexelOffset:                                   VkUint32;
    minTexelGatherOffset:                             VkInt32;
    maxTexelGatherOffset:                             VkUint32;
    minInterpolationOffset:                           VkFloat;
    maxInterpolationOffset:                           VkFloat;
    subPixelInterpolationOffsetBits:                  VkUint32;
    maxFramebufferWidth:                              VkUint32;
    maxFramebufferHeight:                             VkUint32;
    maxFramebufferLayers:                             VkUint32;
    framebufferColorSampleCounts:                     VkSampleCountFlags;
    framebufferDepthSampleCounts:                     VkSampleCountFlags;
    framebufferStencilSampleCounts:                   VkSampleCountFlags;
    framebufferNoAttachmentsSampleCounts:             VkSampleCountFlags;
    maxColorAttachments:                              VkUint32;
    sampledImageColorSampleCounts:                    VkSampleCountFlags;
    sampledImageIntegerSampleCounts:                  VkSampleCountFlags;
    sampledImageDepthSampleCounts:                    VkSampleCountFlags;
    sampledImageStencilSampleCounts:                  VkSampleCountFlags;
    storageImageSampleCounts:                         VkSampleCountFlags;
    maxSampleMaskWords:                               VkUint32;
    timestampComputeAndGraphics:                      VkBool32;
    timestampPeriod:                                  VkFloat;
    maxClipDistances:                                 VkUint32;
    maxCullDistances:                                 VkUint32;
    maxCombinedClipAndCullDistances:                  VkUint32;
    discreteQueuePriorities:                          VkUint32;
    pointSizeRange:                                   array[0..1] of VkFloat;
    lineWidthRange:                                   array[0..1] of VkFloat;
    pointSizeGranularity:                             VkFloat;
    lineWidthGranularity:                             VkFloat;
    strictLines:                                      VkBool32;
    standardSampleLocations:                          VkBool32;
    optimalBufferCopyOffsetAlignment:                 VkDeviceSize;
    optimalBufferCopyRowPitchAlignment:               VkDeviceSize;
    nonCoherentAtomSize:                              VkDeviceSize;
  end;
  PVkPhysicalDeviceLimits = ^TVkPhysicalDeviceLimits;
  PPVkPhysicalDeviceLimits = ^PVkPhysicalDeviceLimits;

  TVkPhysicalDeviceSparseProperties = record
    residencyStandard2DBlockShape:                    VkBool32;
    residencyStandard2DMultisampleBlockShape:         VkBool32;
    residencyStandard3DBlockShape:                    VkBool32;
    residencyAlignedMipSize:                          VkBool32;
    residencyNonResidentStrict:                       VkBool32;
  end;
  PVkPhysicalDeviceSparseProperties = ^TVkPhysicalDeviceSparseProperties;
  PPVkPhysicalDeviceSparseProperties = ^PVkPhysicalDeviceSparseProperties;

  TVkPhysicalDeviceProperties = record
    apiVersion:                                       VkUint32;
    driverVersion:                                    VkUint32;
    vendorID:                                         VkUint32;
    deviceID:                                         VkUint32;
    deviceType:                                       TVkPhysicalDeviceType;
    deviceName:                                       array[0..VK_MAX_PHYSICAL_DEVICE_NAME_SIZE-1] of VkChar;
    pipelineCacheUUID:                                array[0..VK_UUID_SIZE-1] of VkUint8;
    limits:                                           TVkPhysicalDeviceLimits;
    sparseProperties:                                 TVkPhysicalDeviceSparseProperties;
  end;
  PVkPhysicalDeviceProperties = ^TVkPhysicalDeviceProperties;
  PPVkPhysicalDeviceProperties = ^PVkPhysicalDeviceProperties;

  TVkQueueFamilyProperties = record
    queueFlags:                                       VkQueueFlags;
    queueCount:                                       VkUint32;
    timestampValidBits:                               VkUint32;
    minImageTransferGranularity:                      TVkExtent3D;
  end;
  PVkQueueFamilyProperties = ^TVkQueueFamilyProperties;
  PPVkQueueFamilyProperties = ^PVkQueueFamilyProperties;

  TVkMemoryType = record
    propertyFlags:                                    VkMemoryPropertyFlags;
    heapIndex:                                        VkUint32;
  end;
  PVkMemoryType = ^TVkMemoryType;
  PPVkMemoryType = ^PVkMemoryType;

  TVkMemoryHeap = record
    size:                                             VkDeviceSize;
    flags:                                            VkMemoryHeapFlags;
  end;
  PVkMemoryHeap = ^TVkMemoryHeap;
  PPVkMemoryHeap = ^PVkMemoryHeap;

  TVkPhysicalDeviceMemoryProperties = record
    memoryTypeCount:                                  VkUint32;
    memoryTypes:                                      array[0..VK_MAX_MEMORY_TYPES-1] of TVkMemoryType;
    memoryHeapCount:                                  VkUint32;
    memoryHeaps:                                      array[0..VK_MAX_MEMORY_HEAPS-1] of TVkMemoryHeap;
  end;
  PVkPhysicalDeviceMemoryProperties = ^TVkPhysicalDeviceMemoryProperties;
  PPVkPhysicalDeviceMemoryProperties = ^PVkPhysicalDeviceMemoryProperties;

  TVkDeviceQueueCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDeviceQueueCreateFlags;
    queueFamilyIndex:                                 VkUint32;
    queueCount:                                       VkUint32;
    pQueuePriorities:                                 PVkFloat;
  end;
  PVkDeviceQueueCreateInfo = ^TVkDeviceQueueCreateInfo;
  PPVkDeviceQueueCreateInfo = ^PVkDeviceQueueCreateInfo;

  TVkDeviceCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDeviceCreateFlags;
    queueCreateInfoCount:                             VkUint32;
    pQueueCreateInfos:                                PVkDeviceQueueCreateInfo;
    enabledLayerCount:                                VkUint32;
    ppEnabledLayerNames:                              PPVkChar;
    enabledExtensionCount:                            VkUint32;
    ppEnabledExtensionNames:                          PPVkChar;
    pEnabledFeatures:                                 PVkPhysicalDeviceFeatures;
  end;
  PVkDeviceCreateInfo = ^TVkDeviceCreateInfo;
  PPVkDeviceCreateInfo = ^PVkDeviceCreateInfo;

  TVkExtensionProperties = record
    extensionName:                                    array[0..VK_MAX_EXTENSION_NAME_SIZE-1] of VkChar;
    specVersion:                                      VkUint32;
  end;
  PVkExtensionProperties = ^TVkExtensionProperties;
  PPVkExtensionProperties = ^PVkExtensionProperties;

  TVkLayerProperties = record
    layerName:                                        array[0..VK_MAX_EXTENSION_NAME_SIZE-1] of VkChar;
    specVersion:                                      VkUint32;
    implementationVersion:                            VkUint32;
    description:                                      array[0..VK_MAX_DESCRIPTION_SIZE-1] of VkChar;
  end;
  PVkLayerProperties = ^TVkLayerProperties;
  PPVkLayerProperties = ^PVkLayerProperties;

  TVkSubmitInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    waitSemaphoreCount:                               VkUint32;
    pWaitSemaphores:                                  PVkSemaphore;
    pWaitDstStageMask:                                PVkPipelineStageFlags;
    commandBufferCount:                               VkUint32;
    pCommandBuffers:                                  PVkCommandBuffer;
    signalSemaphoreCount:                             VkUint32;
    pSignalSemaphores:                                PVkSemaphore;
  end;
  PVkSubmitInfo = ^TVkSubmitInfo;
  PPVkSubmitInfo = ^PVkSubmitInfo;

  TVkMemoryAllocateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    allocationSize:                                   VkDeviceSize;
    memoryTypeIndex:                                  VkUint32;
  end;
  PVkMemoryAllocateInfo = ^TVkMemoryAllocateInfo;
  PPVkMemoryAllocateInfo = ^PVkMemoryAllocateInfo;

  TVkMappedMemoryRange = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    memory:                                           VkDeviceMemory;
    offset:                                           VkDeviceSize;
    size:                                             VkDeviceSize;
  end;
  PVkMappedMemoryRange = ^TVkMappedMemoryRange;
  PPVkMappedMemoryRange = ^PVkMappedMemoryRange;

  TVkMemoryRequirements = record
    size:                                             VkDeviceSize;
    alignment:                                        VkDeviceSize;
    memoryTypeBits:                                   VkUint32;
  end;
  PVkMemoryRequirements = ^TVkMemoryRequirements;
  PPVkMemoryRequirements = ^PVkMemoryRequirements;

  TVkSparseImageFormatProperties = record
    aspectMask:                                       VkImageAspectFlags;
    imageGranularity:                                 TVkExtent3D;
    flags:                                            VkSparseImageFormatFlags;
  end;
  PVkSparseImageFormatProperties = ^TVkSparseImageFormatProperties;
  PPVkSparseImageFormatProperties = ^PVkSparseImageFormatProperties;

  TVkSparseImageMemoryRequirements = record
    formatProperties:                                 TVkSparseImageFormatProperties;
    imageMipTailFirstLod:                             VkUint32;
    imageMipTailSize:                                 VkDeviceSize;
    imageMipTailOffset:                               VkDeviceSize;
    imageMipTailStride:                               VkDeviceSize;
  end;
  PVkSparseImageMemoryRequirements = ^TVkSparseImageMemoryRequirements;
  PPVkSparseImageMemoryRequirements = ^PVkSparseImageMemoryRequirements;

  TVkSparseMemoryBind = record
    resourceOffset:                                   VkDeviceSize;
    size:                                             VkDeviceSize;
    memory:                                           VkDeviceMemory;
    memoryOffset:                                     VkDeviceSize;
    flags:                                            VkSparseMemoryBindFlags;
  end;
  PVkSparseMemoryBind = ^TVkSparseMemoryBind;
  PPVkSparseMemoryBind = ^PVkSparseMemoryBind;

  TVkSparseBufferMemoryBindInfo = record
    buffer:                                           VkBuffer;
    bindCount:                                        VkUint32;
    pBinds:                                           PVkSparseMemoryBind;
  end;
  PVkSparseBufferMemoryBindInfo = ^TVkSparseBufferMemoryBindInfo;
  PPVkSparseBufferMemoryBindInfo = ^PVkSparseBufferMemoryBindInfo;

  TVkSparseImageOpaqueMemoryBindInfo = record
    image:                                            VkImage;
    bindCount:                                        VkUint32;
    pBinds:                                           PVkSparseMemoryBind;
  end;
  PVkSparseImageOpaqueMemoryBindInfo = ^TVkSparseImageOpaqueMemoryBindInfo;
  PPVkSparseImageOpaqueMemoryBindInfo = ^PVkSparseImageOpaqueMemoryBindInfo;

  TVkImageSubresource = record
    aspectMask:                                       VkImageAspectFlags;
    mipLevel:                                         VkUint32;
    arrayLayer:                                       VkUint32;
  end;
  PVkImageSubresource = ^TVkImageSubresource;
  PPVkImageSubresource = ^PVkImageSubresource;

  TVkOffset3D = record
    x:                                                VkInt32;
    y:                                                VkInt32;
    z:                                                VkInt32;
  end;
  PVkOffset3D = ^TVkOffset3D;
  PPVkOffset3D = ^PVkOffset3D;

  TVkSparseImageMemoryBind = record
    subresource:                                      TVkImageSubresource;
    offset:                                           TVkOffset3D;
    extent:                                           TVkExtent3D;
    memory:                                           VkDeviceMemory;
    memoryOffset:                                     VkDeviceSize;
    flags:                                            VkSparseMemoryBindFlags;
  end;
  PVkSparseImageMemoryBind = ^TVkSparseImageMemoryBind;
  PPVkSparseImageMemoryBind = ^PVkSparseImageMemoryBind;

  TVkSparseImageMemoryBindInfo = record
    image:                                            VkImage;
    bindCount:                                        VkUint32;
    pBinds:                                           PVkSparseImageMemoryBind;
  end;
  PVkSparseImageMemoryBindInfo = ^TVkSparseImageMemoryBindInfo;
  PPVkSparseImageMemoryBindInfo = ^PVkSparseImageMemoryBindInfo;

  TVkBindSparseInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    waitSemaphoreCount:                               VkUint32;
    pWaitSemaphores:                                  PVkSemaphore;
    bufferBindCount:                                  VkUint32;
    pBufferBinds:                                     PVkSparseBufferMemoryBindInfo;
    imageOpaqueBindCount:                             VkUint32;
    pImageOpaqueBinds:                                PVkSparseImageOpaqueMemoryBindInfo;
    imageBindCount:                                   VkUint32;
    pImageBinds:                                      PVkSparseImageMemoryBindInfo;
    signalSemaphoreCount:                             VkUint32;
    pSignalSemaphores:                                PVkSemaphore;
  end;
  PVkBindSparseInfo = ^TVkBindSparseInfo;
  PPVkBindSparseInfo = ^PVkBindSparseInfo;

  TVkFenceCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkFenceCreateFlags;
  end;
  PVkFenceCreateInfo = ^TVkFenceCreateInfo;
  PPVkFenceCreateInfo = ^PVkFenceCreateInfo;

  TVkSemaphoreCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkSemaphoreCreateFlags;
  end;
  PVkSemaphoreCreateInfo = ^TVkSemaphoreCreateInfo;
  PPVkSemaphoreCreateInfo = ^PVkSemaphoreCreateInfo;

  TVkEventCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkEventCreateFlags;
  end;
  PVkEventCreateInfo = ^TVkEventCreateInfo;
  PPVkEventCreateInfo = ^PVkEventCreateInfo;

  TVkQueryPoolCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkQueryPoolCreateFlags;
    queryType:                                        TVkQueryType;
    queryCount:                                       VkUint32;
    pipelineStatistics:                               VkQueryPipelineStatisticFlags;
  end;
  PVkQueryPoolCreateInfo = ^TVkQueryPoolCreateInfo;
  PPVkQueryPoolCreateInfo = ^PVkQueryPoolCreateInfo;

  TVkBufferCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkBufferCreateFlags;
    size:                                             VkDeviceSize;
    usage:                                            VkBufferUsageFlags;
    sharingMode:                                      TVkSharingMode;
    queueFamilyIndexCount:                            VkUint32;
    pQueueFamilyIndices:                              PVkUint32;
  end;
  PVkBufferCreateInfo = ^TVkBufferCreateInfo;
  PPVkBufferCreateInfo = ^PVkBufferCreateInfo;

  TVkBufferViewCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkBufferViewCreateFlags;
    buffer:                                           VkBuffer;
    format:                                           TVkFormat;
    offset:                                           VkDeviceSize;
    range:                                            VkDeviceSize;
  end;
  PVkBufferViewCreateInfo = ^TVkBufferViewCreateInfo;
  PPVkBufferViewCreateInfo = ^PVkBufferViewCreateInfo;

  TVkImageCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkImageCreateFlags;
    imageType:                                        TVkImageType;
    format:                                           TVkFormat;
    extent:                                           TVkExtent3D;
    mipLevels:                                        VkUint32;
    arrayLayers:                                      VkUint32;
    samples:                                          TVkSampleCountFlagBits;
    tiling:                                           TVkImageTiling;
    usage:                                            VkImageUsageFlags;
    sharingMode:                                      TVkSharingMode;
    queueFamilyIndexCount:                            VkUint32;
    pQueueFamilyIndices:                              PVkUint32;
    initialLayout:                                    TVkImageLayout;
  end;
  PVkImageCreateInfo = ^TVkImageCreateInfo;
  PPVkImageCreateInfo = ^PVkImageCreateInfo;

  TVkSubresourceLayout = record
    offset:                                           VkDeviceSize;
    size:                                             VkDeviceSize;
    rowPitch:                                         VkDeviceSize;
    arrayPitch:                                       VkDeviceSize;
    depthPitch:                                       VkDeviceSize;
  end;
  PVkSubresourceLayout = ^TVkSubresourceLayout;
  PPVkSubresourceLayout = ^PVkSubresourceLayout;

  TVkComponentMapping = record
    r:                                                TVkComponentSwizzle;
    g:                                                TVkComponentSwizzle;
    b:                                                TVkComponentSwizzle;
    a:                                                TVkComponentSwizzle;
  end;
  PVkComponentMapping = ^TVkComponentMapping;
  PPVkComponentMapping = ^PVkComponentMapping;

  TVkImageSubresourceRange = record
    aspectMask:                                       VkImageAspectFlags;
    baseMipLevel:                                     VkUint32;
    levelCount:                                       VkUint32;
    baseArrayLayer:                                   VkUint32;
    layerCount:                                       VkUint32;
  end;
  PVkImageSubresourceRange = ^TVkImageSubresourceRange;
  PPVkImageSubresourceRange = ^PVkImageSubresourceRange;

  TVkImageViewCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkImageViewCreateFlags;
    image:                                            VkImage;
    viewType:                                         TVkImageViewType;
    format:                                           TVkFormat;
    components:                                       TVkComponentMapping;
    subresourceRange:                                 TVkImageSubresourceRange;
  end;
  PVkImageViewCreateInfo = ^TVkImageViewCreateInfo;
  PPVkImageViewCreateInfo = ^PVkImageViewCreateInfo;

  TVkShaderModuleCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkShaderModuleCreateFlags;
    codeSize:                                         VkSize;
    pCode:                                            PVkUint32;
  end;
  PVkShaderModuleCreateInfo = ^TVkShaderModuleCreateInfo;
  PPVkShaderModuleCreateInfo = ^PVkShaderModuleCreateInfo;

  TVkPipelineCacheCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineCacheCreateFlags;
    initialDataSize:                                  VkSize;
    pInitialData:                                     PVkVoid;
  end;
  PVkPipelineCacheCreateInfo = ^TVkPipelineCacheCreateInfo;
  PPVkPipelineCacheCreateInfo = ^PVkPipelineCacheCreateInfo;

  TVkSpecializationMapEntry = record
    constantID:                                       VkUint32;
    offset:                                           VkUint32;
    size:                                             VkSize;
  end;
  PVkSpecializationMapEntry = ^TVkSpecializationMapEntry;
  PPVkSpecializationMapEntry = ^PVkSpecializationMapEntry;

  TVkSpecializationInfo = record
    mapEntryCount:                                    VkUint32;
    pMapEntries:                                      PVkSpecializationMapEntry;
    dataSize:                                         VkSize;
    pData:                                            PVkVoid;
  end;
  PVkSpecializationInfo = ^TVkSpecializationInfo;
  PPVkSpecializationInfo = ^PVkSpecializationInfo;

  TVkPipelineShaderStageCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineShaderStageCreateFlags;
    stage:                                            TVkShaderStageFlagBits;
    module:                                           VkShaderModule;
    pName:                                            PVkChar;
    pSpecializationInfo:                              PVkSpecializationInfo;
  end;
  PVkPipelineShaderStageCreateInfo = ^TVkPipelineShaderStageCreateInfo;
  PPVkPipelineShaderStageCreateInfo = ^PVkPipelineShaderStageCreateInfo;

  TVkVertexInputBindingDescription = record
    binding:                                          VkUint32;
    stride:                                           VkUint32;
    inputRate:                                        TVkVertexInputRate;
  end;
  PVkVertexInputBindingDescription = ^TVkVertexInputBindingDescription;
  PPVkVertexInputBindingDescription = ^PVkVertexInputBindingDescription;

  TVkVertexInputAttributeDescription = record
    location:                                         VkUint32;
    binding:                                          VkUint32;
    format:                                           TVkFormat;
    offset:                                           VkUint32;
  end;
  PVkVertexInputAttributeDescription = ^TVkVertexInputAttributeDescription;
  PPVkVertexInputAttributeDescription = ^PVkVertexInputAttributeDescription;

  TVkPipelineVertexInputStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount:                    VkUint32;
    pVertexBindingDescriptions:                       PVkVertexInputBindingDescription;
    vertexAttributeDescriptionCount:                  VkUint32;
    pVertexAttributeDescriptions:                     PVkVertexInputAttributeDescription;
  end;
  PVkPipelineVertexInputStateCreateInfo = ^TVkPipelineVertexInputStateCreateInfo;
  PPVkPipelineVertexInputStateCreateInfo = ^PVkPipelineVertexInputStateCreateInfo;

  TVkPipelineInputAssemblyStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineInputAssemblyStateCreateFlags;
    topology:                                         TVkPrimitiveTopology;
    primitiveRestartEnable:                           VkBool32;
  end;
  PVkPipelineInputAssemblyStateCreateInfo = ^TVkPipelineInputAssemblyStateCreateInfo;
  PPVkPipelineInputAssemblyStateCreateInfo = ^PVkPipelineInputAssemblyStateCreateInfo;

  TVkPipelineTessellationStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineTessellationStateCreateFlags;
    patchControlPoints:                               VkUint32;
  end;
  PVkPipelineTessellationStateCreateInfo = ^TVkPipelineTessellationStateCreateInfo;
  PPVkPipelineTessellationStateCreateInfo = ^PVkPipelineTessellationStateCreateInfo;

  TVkViewport = record
    x:                                                VkFloat;
    y:                                                VkFloat;
    width:                                            VkFloat;
    height:                                           VkFloat;
    minDepth:                                         VkFloat;
    maxDepth:                                         VkFloat;
  end;
  PVkViewport = ^TVkViewport;
  PPVkViewport = ^PVkViewport;

  TVkOffset2D = record
    x:                                                VkInt32;
    y:                                                VkInt32;
  end;
  PVkOffset2D = ^TVkOffset2D;
  PPVkOffset2D = ^PVkOffset2D;

  TVkExtent2D = record
    width:                                            VkUint32;
    height:                                           VkUint32;
  end;
  PVkExtent2D = ^TVkExtent2D;
  PPVkExtent2D = ^PVkExtent2D;

  TVkRect2D = record
    offset:                                           TVkOffset2D;
    extent:                                           TVkExtent2D;
  end;
  PVkRect2D = ^TVkRect2D;
  PPVkRect2D = ^PVkRect2D;

  TVkPipelineViewportStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineViewportStateCreateFlags;
    viewportCount:                                    VkUint32;
    pViewports:                                       PVkViewport;
    scissorCount:                                     VkUint32;
    pScissors:                                        PVkRect2D;
  end;
  PVkPipelineViewportStateCreateInfo = ^TVkPipelineViewportStateCreateInfo;
  PPVkPipelineViewportStateCreateInfo = ^PVkPipelineViewportStateCreateInfo;

  TVkPipelineRasterizationStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineRasterizationStateCreateFlags;
    depthClampEnable:                                 VkBool32;
    rasterizerDiscardEnable:                          VkBool32;
    polygonMode:                                      TVkPolygonMode;
    cullMode:                                         VkCullModeFlags;
    frontFace:                                        TVkFrontFace;
    depthBiasEnable:                                  VkBool32;
    depthBiasConstantFactor:                          VkFloat;
    depthBiasClamp:                                   VkFloat;
    depthBiasSlopeFactor:                             VkFloat;
    lineWidth:                                        VkFloat;
  end;
  PVkPipelineRasterizationStateCreateInfo = ^TVkPipelineRasterizationStateCreateInfo;
  PPVkPipelineRasterizationStateCreateInfo = ^PVkPipelineRasterizationStateCreateInfo;

  TVkPipelineMultisampleStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineMultisampleStateCreateFlags;
    rasterizationSamples:                             TVkSampleCountFlagBits;
    sampleShadingEnable:                              VkBool32;
    minSampleShading:                                 VkFloat;
    pSampleMask:                                      PVkSampleMask;
    alphaToCoverageEnable:                            VkBool32;
    alphaToOneEnable:                                 VkBool32;
  end;
  PVkPipelineMultisampleStateCreateInfo = ^TVkPipelineMultisampleStateCreateInfo;
  PPVkPipelineMultisampleStateCreateInfo = ^PVkPipelineMultisampleStateCreateInfo;

  TVkStencilOpState = record
    failOp:                                           TVkStencilOp;
    passOp:                                           TVkStencilOp;
    depthFailOp:                                      TVkStencilOp;
    compareOp:                                        TVkCompareOp;
    compareMask:                                      VkUint32;
    writeMask:                                        VkUint32;
    reference:                                        VkUint32;
  end;
  PVkStencilOpState = ^TVkStencilOpState;
  PPVkStencilOpState = ^PVkStencilOpState;

  TVkPipelineDepthStencilStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineDepthStencilStateCreateFlags;
    depthTestEnable:                                  VkBool32;
    depthWriteEnable:                                 VkBool32;
    depthCompareOp:                                   TVkCompareOp;
    depthBoundsTestEnable:                            VkBool32;
    stencilTestEnable:                                VkBool32;
    front:                                            TVkStencilOpState;
    back:                                             TVkStencilOpState;
    minDepthBounds:                                   VkFloat;
    maxDepthBounds:                                   VkFloat;
  end;
  PVkPipelineDepthStencilStateCreateInfo = ^TVkPipelineDepthStencilStateCreateInfo;
  PPVkPipelineDepthStencilStateCreateInfo = ^PVkPipelineDepthStencilStateCreateInfo;

  TVkPipelineColorBlendAttachmentState = record
    blendEnable:                                      VkBool32;
    srcColorBlendFactor:                              TVkBlendFactor;
    dstColorBlendFactor:                              TVkBlendFactor;
    colorBlendOp:                                     TVkBlendOp;
    srcAlphaBlendFactor:                              TVkBlendFactor;
    dstAlphaBlendFactor:                              TVkBlendFactor;
    alphaBlendOp:                                     TVkBlendOp;
    colorWriteMask:                                   VkColorComponentFlags;
  end;
  PVkPipelineColorBlendAttachmentState = ^TVkPipelineColorBlendAttachmentState;
  PPVkPipelineColorBlendAttachmentState = ^PVkPipelineColorBlendAttachmentState;

  TVkPipelineColorBlendStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineColorBlendStateCreateFlags;
    logicOpEnable:                                    VkBool32;
    logicOp:                                          TVkLogicOp;
    attachmentCount:                                  VkUint32;
    pAttachments:                                     PVkPipelineColorBlendAttachmentState;
    blendConstants:                                   array[0..3] of VkFloat;
  end;
  PVkPipelineColorBlendStateCreateInfo = ^TVkPipelineColorBlendStateCreateInfo;
  PPVkPipelineColorBlendStateCreateInfo = ^PVkPipelineColorBlendStateCreateInfo;

  TVkPipelineDynamicStateCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineDynamicStateCreateFlags;
    dynamicStateCount:                                VkUint32;
    pDynamicStates:                                   PVkDynamicState;
  end;
  PVkPipelineDynamicStateCreateInfo = ^TVkPipelineDynamicStateCreateInfo;
  PPVkPipelineDynamicStateCreateInfo = ^PVkPipelineDynamicStateCreateInfo;

  TVkGraphicsPipelineCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineCreateFlags;
    stageCount:                                       VkUint32;
    pStages:                                          PVkPipelineShaderStageCreateInfo;
    pVertexInputState:                                PVkPipelineVertexInputStateCreateInfo;
    pInputAssemblyState:                              PVkPipelineInputAssemblyStateCreateInfo;
    pTessellationState:                               PVkPipelineTessellationStateCreateInfo;
    pViewportState:                                   PVkPipelineViewportStateCreateInfo;
    pRasterizationState:                              PVkPipelineRasterizationStateCreateInfo;
    pMultisampleState:                                PVkPipelineMultisampleStateCreateInfo;
    pDepthStencilState:                               PVkPipelineDepthStencilStateCreateInfo;
    pColorBlendState:                                 PVkPipelineColorBlendStateCreateInfo;
    pDynamicState:                                    PVkPipelineDynamicStateCreateInfo;
    layout:                                           VkPipelineLayout;
    renderPass:                                       VkRenderPass;
    subpass:                                          VkUint32;
    basePipelineHandle:                               VkPipeline;
    basePipelineIndex:                                VkInt32;
  end;
  PVkGraphicsPipelineCreateInfo = ^TVkGraphicsPipelineCreateInfo;
  PPVkGraphicsPipelineCreateInfo = ^PVkGraphicsPipelineCreateInfo;

  TVkComputePipelineCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineCreateFlags;
    stage:                                            TVkPipelineShaderStageCreateInfo;
    layout:                                           VkPipelineLayout;
    basePipelineHandle:                               VkPipeline;
    basePipelineIndex:                                VkInt32;
  end;
  PVkComputePipelineCreateInfo = ^TVkComputePipelineCreateInfo;
  PPVkComputePipelineCreateInfo = ^PVkComputePipelineCreateInfo;

  TVkPushConstantRange = record
    stageFlags:                                       VkShaderStageFlags;
    offset:                                           VkUint32;
    size:                                             VkUint32;
  end;
  PVkPushConstantRange = ^TVkPushConstantRange;
  PPVkPushConstantRange = ^PVkPushConstantRange;

  TVkPipelineLayoutCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkPipelineLayoutCreateFlags;
    setLayoutCount:                                   VkUint32;
    pSetLayouts:                                      PVkDescriptorSetLayout;
    pushConstantRangeCount:                           VkUint32;
    pPushConstantRanges:                              PVkPushConstantRange;
  end;
  PVkPipelineLayoutCreateInfo = ^TVkPipelineLayoutCreateInfo;
  PPVkPipelineLayoutCreateInfo = ^PVkPipelineLayoutCreateInfo;

  TVkSamplerCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkSamplerCreateFlags;
    magFilter:                                        TVkFilter;
    minFilter:                                        TVkFilter;
    mipmapMode:                                       TVkSamplerMipmapMode;
    addressModeU:                                     TVkSamplerAddressMode;
    addressModeV:                                     TVkSamplerAddressMode;
    addressModeW:                                     TVkSamplerAddressMode;
    mipLodBias:                                       VkFloat;
    anisotropyEnable:                                 VkBool32;
    maxAnisotropy:                                    VkFloat;
    compareEnable:                                    VkBool32;
    compareOp:                                        TVkCompareOp;
    minLod:                                           VkFloat;
    maxLod:                                           VkFloat;
    borderColor:                                      TVkBorderColor;
    unnormalizedCoordinates:                          VkBool32;
  end;
  PVkSamplerCreateInfo = ^TVkSamplerCreateInfo;
  PPVkSamplerCreateInfo = ^PVkSamplerCreateInfo;

  TVkDescriptorSetLayoutBinding = record
    binding:                                          VkUint32;
    descriptorType:                                   TVkDescriptorType;
    descriptorCount:                                  VkUint32;
    stageFlags:                                       VkShaderStageFlags;
    pImmutableSamplers:                               PVkSampler;
  end;
  PVkDescriptorSetLayoutBinding = ^TVkDescriptorSetLayoutBinding;
  PPVkDescriptorSetLayoutBinding = ^PVkDescriptorSetLayoutBinding;

  TVkDescriptorSetLayoutCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDescriptorSetLayoutCreateFlags;
    bindingCount:                                     VkUint32;
    pBindings:                                        PVkDescriptorSetLayoutBinding;
  end;
  PVkDescriptorSetLayoutCreateInfo = ^TVkDescriptorSetLayoutCreateInfo;
  PPVkDescriptorSetLayoutCreateInfo = ^PVkDescriptorSetLayoutCreateInfo;

  TVkDescriptorPoolSize = record
    dType:                                            TVkDescriptorType;
    descriptorCount:                                  VkUint32;
  end;
  PVkDescriptorPoolSize = ^TVkDescriptorPoolSize;
  PPVkDescriptorPoolSize = ^PVkDescriptorPoolSize;

  TVkDescriptorPoolCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDescriptorPoolCreateFlags;
    maxSets:                                          VkUint32;
    poolSizeCount:                                    VkUint32;
    pPoolSizes:                                       PVkDescriptorPoolSize;
  end;
  PVkDescriptorPoolCreateInfo = ^TVkDescriptorPoolCreateInfo;
  PPVkDescriptorPoolCreateInfo = ^PVkDescriptorPoolCreateInfo;

  TVkDescriptorSetAllocateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    descriptorPool:                                   VkDescriptorPool;
    descriptorSetCount:                               VkUint32;
    pSetLayouts:                                      PVkDescriptorSetLayout;
  end;
  PVkDescriptorSetAllocateInfo = ^TVkDescriptorSetAllocateInfo;
  PPVkDescriptorSetAllocateInfo = ^PVkDescriptorSetAllocateInfo;

  TVkDescriptorImageInfo = record
    sampler:                                          VkSampler;
    imageView:                                        VkImageView;
    imageLayout:                                      TVkImageLayout;
  end;
  PVkDescriptorImageInfo = ^TVkDescriptorImageInfo;
  PPVkDescriptorImageInfo = ^PVkDescriptorImageInfo;

  TVkDescriptorBufferInfo = record
    buffer:                                           VkBuffer;
    offset:                                           VkDeviceSize;
    range:                                            VkDeviceSize;
  end;
  PVkDescriptorBufferInfo = ^TVkDescriptorBufferInfo;
  PPVkDescriptorBufferInfo = ^PVkDescriptorBufferInfo;

  TVkWriteDescriptorSet = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    dstSet:                                           VkDescriptorSet;
    dstBinding:                                       VkUint32;
    dstArrayElement:                                  VkUint32;
    descriptorCount:                                  VkUint32;
    descriptorType:                                   TVkDescriptorType;
    pImageInfo:                                       PVkDescriptorImageInfo;
    pBufferInfo:                                      PVkDescriptorBufferInfo;
    pTexelBufferView:                                 PVkBufferView;
  end;
  PVkWriteDescriptorSet = ^TVkWriteDescriptorSet;
  PPVkWriteDescriptorSet = ^PVkWriteDescriptorSet;

  TVkCopyDescriptorSet = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    srcSet:                                           VkDescriptorSet;
    srcBinding:                                       VkUint32;
    srcArrayElement:                                  VkUint32;
    dstSet:                                           VkDescriptorSet;
    dstBinding:                                       VkUint32;
    dstArrayElement:                                  VkUint32;
    descriptorCount:                                  VkUint32;
  end;
  PVkCopyDescriptorSet = ^TVkCopyDescriptorSet;
  PPVkCopyDescriptorSet = ^PVkCopyDescriptorSet;

  TVkFramebufferCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkFramebufferCreateFlags;
    renderPass:                                       VkRenderPass;
    attachmentCount:                                  VkUint32;
    pAttachments:                                     PVkImageView;
    width:                                            VkUint32;
    height:                                           VkUint32;
    layers:                                           VkUint32;
  end;
  PVkFramebufferCreateInfo = ^TVkFramebufferCreateInfo;
  PPVkFramebufferCreateInfo = ^PVkFramebufferCreateInfo;

  TVkAttachmentDescription = record
    flags:                                            VkAttachmentDescriptionFlags;
    format:                                           TVkFormat;
    samples:                                          TVkSampleCountFlagBits;
    loadOp:                                           TVkAttachmentLoadOp;
    storeOp:                                          TVkAttachmentStoreOp;
    stencilLoadOp:                                    TVkAttachmentLoadOp;
    stencilStoreOp:                                   TVkAttachmentStoreOp;
    initialLayout:                                    TVkImageLayout;
    finalLayout:                                      TVkImageLayout;
  end;
  PVkAttachmentDescription = ^TVkAttachmentDescription;
  PPVkAttachmentDescription = ^PVkAttachmentDescription;

  TVkAttachmentReference = record
    attachment:                                       VkUint32;
    layout:                                           TVkImageLayout;
  end;
  PVkAttachmentReference = ^TVkAttachmentReference;
  PPVkAttachmentReference = ^PVkAttachmentReference;

  TVkSubpassDescription = record
    flags:                                            VkSubpassDescriptionFlags;
    pipelineBindPoint:                                TVkPipelineBindPoint;
    inputAttachmentCount:                             VkUint32;
    pInputAttachments:                                PVkAttachmentReference;
    colorAttachmentCount:                             VkUint32;
    pColorAttachments:                                PVkAttachmentReference;
    pResolveAttachments:                              PVkAttachmentReference;
    pDepthStencilAttachment:                          PVkAttachmentReference;
    preserveAttachmentCount:                          VkUint32;
    pPreserveAttachments:                             PVkUint32;
  end;
  PVkSubpassDescription = ^TVkSubpassDescription;
  PPVkSubpassDescription = ^PVkSubpassDescription;

  TVkSubpassDependency = record
    srcSubpass:                                       VkUint32;
    dstSubpass:                                       VkUint32;
    srcStageMask:                                     VkPipelineStageFlags;
    dstStageMask:                                     VkPipelineStageFlags;
    srcAccessMask:                                    VkAccessFlags;
    dstAccessMask:                                    VkAccessFlags;
    dependencyFlags:                                  VkDependencyFlags;
  end;
  PVkSubpassDependency = ^TVkSubpassDependency;
  PPVkSubpassDependency = ^PVkSubpassDependency;

  TVkRenderPassCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkRenderPassCreateFlags;
    attachmentCount:                                  VkUint32;
    pAttachments:                                     PVkAttachmentDescription;
    subpassCount:                                     VkUint32;
    pSubpasses:                                       PVkSubpassDescription;
    dependencyCount:                                  VkUint32;
    pDependencies:                                    PVkSubpassDependency;
  end;
  PVkRenderPassCreateInfo = ^TVkRenderPassCreateInfo;
  PPVkRenderPassCreateInfo = ^PVkRenderPassCreateInfo;

  TVkCommandPoolCreateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkCommandPoolCreateFlags;
    queueFamilyIndex:                                 VkUint32;
  end;
  PVkCommandPoolCreateInfo = ^TVkCommandPoolCreateInfo;
  PPVkCommandPoolCreateInfo = ^PVkCommandPoolCreateInfo;

  TVkCommandBufferAllocateInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    commandPool:                                      VkCommandPool;
    level:                                            TVkCommandBufferLevel;
    commandBufferCount:                               VkUint32;
  end;
  PVkCommandBufferAllocateInfo = ^TVkCommandBufferAllocateInfo;
  PPVkCommandBufferAllocateInfo = ^PVkCommandBufferAllocateInfo;

  TVkCommandBufferInheritanceInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    renderPass:                                       VkRenderPass;
    subpass:                                          VkUint32;
    framebuffer:                                      VkFramebuffer;
    occlusionQueryEnable:                             VkBool32;
    queryFlags:                                       VkQueryControlFlags;
    pipelineStatistics:                               VkQueryPipelineStatisticFlags;
  end;
  PVkCommandBufferInheritanceInfo = ^TVkCommandBufferInheritanceInfo;
  PPVkCommandBufferInheritanceInfo = ^PVkCommandBufferInheritanceInfo;

  TVkCommandBufferBeginInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkCommandBufferUsageFlags;
    pInheritanceInfo:                                 PVkCommandBufferInheritanceInfo;
  end;
  PVkCommandBufferBeginInfo = ^TVkCommandBufferBeginInfo;
  PPVkCommandBufferBeginInfo = ^PVkCommandBufferBeginInfo;

  TVkBufferCopy = record
    srcOffset:                                        VkDeviceSize;
    dstOffset:                                        VkDeviceSize;
    size:                                             VkDeviceSize;
  end;
  PVkBufferCopy = ^TVkBufferCopy;
  PPVkBufferCopy = ^PVkBufferCopy;

  TVkImageSubresourceLayers = record
    aspectMask:                                       VkImageAspectFlags;
    mipLevel:                                         VkUint32;
    baseArrayLayer:                                   VkUint32;
    layerCount:                                       VkUint32;
  end;
  PVkImageSubresourceLayers = ^TVkImageSubresourceLayers;
  PPVkImageSubresourceLayers = ^PVkImageSubresourceLayers;

  TVkImageCopy = record
    srcSubresource:                                   TVkImageSubresourceLayers;
    srcOffset:                                        TVkOffset3D;
    dstSubresource:                                   TVkImageSubresourceLayers;
    dstOffset:                                        TVkOffset3D;
    extent:                                           TVkExtent3D;
  end;
  PVkImageCopy = ^TVkImageCopy;
  PPVkImageCopy = ^PVkImageCopy;

  TVkImageBlit = record
    srcSubresource:                                   TVkImageSubresourceLayers;
    srcOffsets:                                       array[0..1] of TVkOffset3D;
    dstSubresource:                                   TVkImageSubresourceLayers;
    dstOffsets:                                       array[0..1] of TVkOffset3D;
  end;
  PVkImageBlit = ^TVkImageBlit;
  PPVkImageBlit = ^PVkImageBlit;

  TVkBufferImageCopy = record
    bufferOffset:                                     VkDeviceSize;
    bufferRowLength:                                  VkUint32;
    bufferImageHeight:                                VkUint32;
    imageSubresource:                                 TVkImageSubresourceLayers;
    imageOffset:                                      TVkOffset3D;
    imageExtent:                                      TVkExtent3D;
  end;
  PVkBufferImageCopy = ^TVkBufferImageCopy;
  PPVkBufferImageCopy = ^PVkBufferImageCopy;

  TVkClearColorValue = record
    case Integer of
      000: (float32:                                  array[0..3] of VkFloat);
      001: (int32:                                    array[0..3] of VkInt32);
      002: (uint32:                                   array[0..3] of VkUint32);
  end;
  PVkClearColorValue = ^TVkClearColorValue;
  PPVkClearColorValue = ^PVkClearColorValue;

  TVkClearDepthStencilValue = record
    depth:                                            VkFloat;
    stencil:                                          VkUint32;
  end;
  PVkClearDepthStencilValue = ^TVkClearDepthStencilValue;
  PPVkClearDepthStencilValue = ^PVkClearDepthStencilValue;

  TVkClearValue = record
    case Integer of
      000: (color:                                    TVkClearColorValue);
      001: (depthStencil:                             TVkClearDepthStencilValue);
  end;
  PVkClearValue = ^TVkClearValue;
  PPVkClearValue = ^PVkClearValue;

  TVkClearAttachment = record
    aspectMask:                                       VkImageAspectFlags;
    colorAttachment:                                  VkUint32;
    clearValue:                                       TVkClearValue;
  end;
  PVkClearAttachment = ^TVkClearAttachment;
  PPVkClearAttachment = ^PVkClearAttachment;

  TVkClearRect = record
    rect:                                             TVkRect2D;
    baseArrayLayer:                                   VkUint32;
    layerCount:                                       VkUint32;
  end;
  PVkClearRect = ^TVkClearRect;
  PPVkClearRect = ^PVkClearRect;

  TVkImageResolve = record
    srcSubresource:                                   TVkImageSubresourceLayers;
    srcOffset:                                        TVkOffset3D;
    dstSubresource:                                   TVkImageSubresourceLayers;
    dstOffset:                                        TVkOffset3D;
    extent:                                           TVkExtent3D;
  end;
  PVkImageResolve = ^TVkImageResolve;
  PPVkImageResolve = ^PVkImageResolve;

  TVkMemoryBarrier = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    srcAccessMask:                                    VkAccessFlags;
    dstAccessMask:                                    VkAccessFlags;
  end;
  PVkMemoryBarrier = ^TVkMemoryBarrier;
  PPVkMemoryBarrier = ^PVkMemoryBarrier;

  TVkBufferMemoryBarrier = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    srcAccessMask:                                    VkAccessFlags;
    dstAccessMask:                                    VkAccessFlags;
    srcQueueFamilyIndex:                              VkUint32;
    dstQueueFamilyIndex:                              VkUint32;
    buffer:                                           VkBuffer;
    offset:                                           VkDeviceSize;
    size:                                             VkDeviceSize;
  end;
  PVkBufferMemoryBarrier = ^TVkBufferMemoryBarrier;
  PPVkBufferMemoryBarrier = ^PVkBufferMemoryBarrier;

  TVkImageMemoryBarrier = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    srcAccessMask:                                    VkAccessFlags;
    dstAccessMask:                                    VkAccessFlags;
    oldLayout:                                        TVkImageLayout;
    newLayout:                                        TVkImageLayout;
    srcQueueFamilyIndex:                              VkUint32;
    dstQueueFamilyIndex:                              VkUint32;
    image:                                            VkImage;
    subresourceRange:                                 TVkImageSubresourceRange;
  end;
  PVkImageMemoryBarrier = ^TVkImageMemoryBarrier;
  PPVkImageMemoryBarrier = ^PVkImageMemoryBarrier;

  TVkRenderPassBeginInfo = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    renderPass:                                       VkRenderPass;
    framebuffer:                                      VkFramebuffer;
    renderArea:                                       TVkRect2D;
    clearValueCount:                                  VkUint32;
    pClearValues:                                     PVkClearValue;
  end;
  PVkRenderPassBeginInfo = ^TVkRenderPassBeginInfo;
  PPVkRenderPassBeginInfo = ^PVkRenderPassBeginInfo;

  TVkDispatchIndirectCommand = record
    x:                                                VkUint32;
    y:                                                VkUint32;
    z:                                                VkUint32;
  end;
  PVkDispatchIndirectCommand = ^TVkDispatchIndirectCommand;
  PPVkDispatchIndirectCommand = ^PVkDispatchIndirectCommand;

  TVkDrawIndexedIndirectCommand = record
    indexCount:                                       VkUint32;
    instanceCount:                                    VkUint32;
    firstIndex:                                       VkUint32;
    vertexOffset:                                     VkInt32;
    firstInstance:                                    VkUint32;
  end;
  PVkDrawIndexedIndirectCommand = ^TVkDrawIndexedIndirectCommand;
  PPVkDrawIndexedIndirectCommand = ^PVkDrawIndexedIndirectCommand;

  TVkDrawIndirectCommand = record
    vertexCount:                                      VkUint32;
    instanceCount:                                    VkUint32;
    firstVertex:                                      VkUint32;
    firstInstance:                                    VkUint32;
  end;
  PVkDrawIndirectCommand = ^TVkDrawIndirectCommand;
  PPVkDrawIndirectCommand = ^PVkDrawIndirectCommand;

{ ========================================== VK_KHR_surface ========================================== }
  TVkSurfaceCapabilitiesKHR = record
    minImageCount:                                    VkUint32;
    maxImageCount:                                    VkUint32;
    currentExtent:                                    TVkExtent2D;
    minImageExtent:                                   TVkExtent2D;
    maxImageExtent:                                   TVkExtent2D;
    maxImageArrayLayers:                              VkUint32;
    supportedTransforms:                              VkSurfaceTransformFlagsKHR;
    currentTransform:                                 TVkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha:                          VkCompositeAlphaFlagsKHR;
    supportedUsageFlags:                              VkImageUsageFlags;
  end;
  PVkSurfaceCapabilitiesKHR = ^TVkSurfaceCapabilitiesKHR;
  PPVkSurfaceCapabilitiesKHR = ^PVkSurfaceCapabilitiesKHR;

  TVkSurfaceFormatKHR = record
    format:                                           TVkFormat;
    colorSpace:                                       TVkColorSpaceKHR;
  end;
  PVkSurfaceFormatKHR = ^TVkSurfaceFormatKHR;
  PPVkSurfaceFormatKHR = ^PVkSurfaceFormatKHR;

{ ========================================= VK_KHR_swapchain ========================================= }
  TVkSwapchainCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkSwapchainCreateFlagsKHR;
    surface:                                          VkSurfaceKHR;
    minImageCount:                                    VkUint32;
    imageFormat:                                      TVkFormat;
    imageColorSpace:                                  TVkColorSpaceKHR;
    imageExtent:                                      TVkExtent2D;
    imageArrayLayers:                                 VkUint32;
    imageUsage:                                       VkImageUsageFlags;
    imageSharingMode:                                 TVkSharingMode;
    queueFamilyIndexCount:                            VkUint32;
    pQueueFamilyIndices:                              PVkUint32;
    preTransform:                                     TVkSurfaceTransformFlagBitsKHR;
    compositeAlpha:                                   TVkCompositeAlphaFlagBitsKHR;
    presentMode:                                      TVkPresentModeKHR;
    clipped:                                          VkBool32;
    oldSwapchain:                                     VkSwapchainKHR;
  end;
  PVkSwapchainCreateInfoKHR = ^TVkSwapchainCreateInfoKHR;
  PPVkSwapchainCreateInfoKHR = ^PVkSwapchainCreateInfoKHR;

  TVkPresentInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    waitSemaphoreCount:                               VkUint32;
    pWaitSemaphores:                                  PVkSemaphore;
    swapchainCount:                                   VkUint32;
    pSwapchains:                                      PVkSwapchainKHR;
    pImageIndices:                                    PVkUint32;
    pResults:                                         PVkResult;
  end;
  PVkPresentInfoKHR = ^TVkPresentInfoKHR;
  PPVkPresentInfoKHR = ^PVkPresentInfoKHR;

{ ========================================== VK_KHR_display ========================================== }
  TVkDisplayPropertiesKHR = record
    display:                                          VkDisplayKHR;
    displayName:                                      PVkChar;
    physicalDimensions:                               TVkExtent2D;
    physicalResolution:                               TVkExtent2D;
    supportedTransforms:                              VkSurfaceTransformFlagsKHR;
    planeReorderPossible:                             VkBool32;
    persistentContent:                                VkBool32;
  end;
  PVkDisplayPropertiesKHR = ^TVkDisplayPropertiesKHR;
  PPVkDisplayPropertiesKHR = ^PVkDisplayPropertiesKHR;

  TVkDisplayModeParametersKHR = record
    visibleRegion:                                    TVkExtent2D;
    refreshRate:                                      VkUint32;
  end;
  PVkDisplayModeParametersKHR = ^TVkDisplayModeParametersKHR;
  PPVkDisplayModeParametersKHR = ^PVkDisplayModeParametersKHR;

  TVkDisplayModePropertiesKHR = record
    displayMode:                                      VkDisplayModeKHR;
    parameters:                                       TVkDisplayModeParametersKHR;
  end;
  PVkDisplayModePropertiesKHR = ^TVkDisplayModePropertiesKHR;
  PPVkDisplayModePropertiesKHR = ^PVkDisplayModePropertiesKHR;

  TVkDisplayModeCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDisplayModeCreateFlagsKHR;
    parameters:                                       TVkDisplayModeParametersKHR;
  end;
  PVkDisplayModeCreateInfoKHR = ^TVkDisplayModeCreateInfoKHR;
  PPVkDisplayModeCreateInfoKHR = ^PVkDisplayModeCreateInfoKHR;

  TVkDisplayPlaneCapabilitiesKHR = record
    supportedAlpha:                                   VkDisplayPlaneAlphaFlagsKHR;
    minSrcPosition:                                   TVkOffset2D;
    maxSrcPosition:                                   TVkOffset2D;
    minSrcExtent:                                     TVkExtent2D;
    maxSrcExtent:                                     TVkExtent2D;
    minDstPosition:                                   TVkOffset2D;
    maxDstPosition:                                   TVkOffset2D;
    minDstExtent:                                     TVkExtent2D;
    maxDstExtent:                                     TVkExtent2D;
  end;
  PVkDisplayPlaneCapabilitiesKHR = ^TVkDisplayPlaneCapabilitiesKHR;
  PPVkDisplayPlaneCapabilitiesKHR = ^PVkDisplayPlaneCapabilitiesKHR;

  TVkDisplayPlanePropertiesKHR = record
    currentDisplay:                                   VkDisplayKHR;
    currentStackIndex:                                VkUint32;
  end;
  PVkDisplayPlanePropertiesKHR = ^TVkDisplayPlanePropertiesKHR;
  PPVkDisplayPlanePropertiesKHR = ^PVkDisplayPlanePropertiesKHR;

  TVkDisplaySurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDisplaySurfaceCreateFlagsKHR;
    displayMode:                                      VkDisplayModeKHR;
    planeIndex:                                       VkUint32;
    planeStackIndex:                                  VkUint32;
    transform:                                        TVkSurfaceTransformFlagBitsKHR;
    globalAlpha:                                      VkFloat;
    alphaMode:                                        TVkDisplayPlaneAlphaFlagBitsKHR;
    imageExtent:                                      TVkExtent2D;
  end;
  PVkDisplaySurfaceCreateInfoKHR = ^TVkDisplaySurfaceCreateInfoKHR;
  PPVkDisplaySurfaceCreateInfoKHR = ^PVkDisplaySurfaceCreateInfoKHR;

{ ===================================== VK_KHR_display_swapchain ===================================== }
  TVkDisplayPresentInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    srcRect:                                          TVkRect2D;
    dstRect:                                          TVkRect2D;
    persistent:                                       VkBool32;
  end;
  PVkDisplayPresentInfoKHR = ^TVkDisplayPresentInfoKHR;
  PPVkDisplayPresentInfoKHR = ^PVkDisplayPresentInfoKHR;

{ ======================================= VK_KHR_xlib_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  TVkXlibSurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkXlibSurfaceCreateFlagsKHR;
    dpy:                                              Display;
    window:                                           Window;
  end;
  PVkXlibSurfaceCreateInfoKHR = ^TVkXlibSurfaceCreateInfoKHR;
  PPVkXlibSurfaceCreateInfoKHR = ^PVkXlibSurfaceCreateInfoKHR;
{$ENDIF}

{ ======================================== VK_KHR_xcb_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  TVkXcbSurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkXcbSurfaceCreateFlagsKHR;
    connection:                                       xcb_connection_t;
    window:                                           xcb_window_t;
  end;
  PVkXcbSurfaceCreateInfoKHR = ^TVkXcbSurfaceCreateInfoKHR;
  PPVkXcbSurfaceCreateInfoKHR = ^PVkXcbSurfaceCreateInfoKHR;
{$ENDIF}

{ ====================================== VK_KHR_wayland_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  TVkWaylandSurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkWaylandSurfaceCreateFlagsKHR;
    display:                                          wl_display;
    surface:                                          wl_surface;
  end;
  PVkWaylandSurfaceCreateInfoKHR = ^TVkWaylandSurfaceCreateInfoKHR;
  PPVkWaylandSurfaceCreateInfoKHR = ^PVkWaylandSurfaceCreateInfoKHR;
{$ENDIF}

{ ======================================== VK_KHR_mir_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  TVkMirSurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkMirSurfaceCreateFlagsKHR;
    connection:                                       MirConnection;
    mirSurface:                                       MirSurface;
  end;
  PVkMirSurfaceCreateInfoKHR = ^TVkMirSurfaceCreateInfoKHR;
  PPVkMirSurfaceCreateInfoKHR = ^PVkMirSurfaceCreateInfoKHR;
{$ENDIF}

{ ====================================== VK_KHR_android_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  TVkAndroidSurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkAndroidSurfaceCreateFlagsKHR;
    window:                                           ANativeWindow;
  end;
  PVkAndroidSurfaceCreateInfoKHR = ^TVkAndroidSurfaceCreateInfoKHR;
  PPVkAndroidSurfaceCreateInfoKHR = ^PVkAndroidSurfaceCreateInfoKHR;
{$ENDIF}

{ ======================================= VK_KHR_win32_surface ======================================= }
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkWin32SurfaceCreateInfoKHR = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkWin32SurfaceCreateFlagsKHR;
    hinstance:                                        HINSTANCE;
    hwnd:                                             HWND;
  end;
  PVkWin32SurfaceCreateInfoKHR = ^TVkWin32SurfaceCreateInfoKHR;
  PPVkWin32SurfaceCreateInfoKHR = ^PVkWin32SurfaceCreateInfoKHR;
{$ENDIF}

{ ======================================= VK_EXT_debug_report ======================================== }
  TVkDebugReportCallbackCreateInfoEXT = record
    sType:                                            TVkStructureType;
    pNext:                                            PVkVoid;
    flags:                                            VkDebugReportFlagsEXT;
    pfnCallback:                                      TvkDebugReportCallbackEXT;
    pUserData:                                        PVkVoid;
  end;
  PVkDebugReportCallbackCreateInfoEXT = ^TVkDebugReportCallbackCreateInfoEXT;
  PPVkDebugReportCallbackCreateInfoEXT = ^PVkDebugReportCallbackCreateInfoEXT;

type { commands }

{ ========================================== VK_VERSION_1_0 ========================================== }
  TvkCreateInstance = function (
    const pCreateInfo:                  PVkInstanceCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pInstance:                    PVkInstance
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyInstance = procedure(
          instance:                     VkInstance; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumeratePhysicalDevices = function (
          instance:                     VkInstance; 
          pPhysicalDeviceCount:         PVkUint32; 
          pPhysicalDevices:             PVkPhysicalDevice
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFeatures = procedure(
          physicalDevice:               VkPhysicalDevice; 
          pFeatures:                    PVkPhysicalDeviceFeatures
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFormatProperties = procedure(
          physicalDevice:               VkPhysicalDevice; 
          format:                       TVkFormat; 
          pFormatProperties:            PVkFormatProperties
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceImageFormatProperties = function (
          physicalDevice:               VkPhysicalDevice; 
          format:                       TVkFormat; 
          iType:                        TVkImageType; 
          tiling:                       TVkImageTiling; 
          usage:                        VkImageUsageFlags; 
          flags:                        VkImageCreateFlags; 
          pImageFormatProperties:       PVkImageFormatProperties
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceProperties = procedure(
          physicalDevice:               VkPhysicalDevice; 
          pProperties:                  PVkPhysicalDeviceProperties
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceQueueFamilyProperties = procedure(
          physicalDevice:               VkPhysicalDevice; 
          pQueueFamilyPropertyCount:    PVkUint32; 
          pQueueFamilyProperties:       PVkQueueFamilyProperties
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMemoryProperties = procedure(
          physicalDevice:               VkPhysicalDevice; 
          pMemoryProperties:            PVkPhysicalDeviceMemoryProperties
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetInstanceProcAddr = function (
          instance:                     VkInstance; 
    const pName:                        PVkChar
  ): TvkVoidFunction; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceProcAddr = function (
          device:                       VkDevice; 
    const pName:                        PVkChar
  ): TvkVoidFunction; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDevice = function (
          physicalDevice:               VkPhysicalDevice; 
    const pCreateInfo:                  PVkDeviceCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pDevice:                      PVkDevice
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDevice = procedure(
          device:                       VkDevice; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceExtensionProperties = function (
    const pLayerName:                   PVkChar; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkExtensionProperties
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceExtensionProperties = function (
          physicalDevice:               VkPhysicalDevice; 
    const pLayerName:                   PVkChar; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkExtensionProperties
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceLayerProperties = function (
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkLayerProperties
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceLayerProperties = function (
          physicalDevice:               VkPhysicalDevice; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkLayerProperties
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceQueue = procedure(
          device:                       VkDevice; 
          queueFamilyIndex:             VkUint32; 
          queueIndex:                   VkUint32; 
          pQueue:                       PVkQueue
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueSubmit = function (
          queue:                        VkQueue; 
          submitCount:                  VkUint32; 
    const pSubmits:                     PVkSubmitInfo; 
          fence:                        VkFence
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueWaitIdle = function (
          queue:                        VkQueue
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDeviceWaitIdle = function (
          device:                       VkDevice
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateMemory = function (
          device:                       VkDevice; 
    const pAllocateInfo:                PVkMemoryAllocateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pMemory:                      PVkDeviceMemory
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeMemory = procedure(
          device:                       VkDevice; 
          memory:                       VkDeviceMemory; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMapMemory = function (
          device:                       VkDevice; 
          memory:                       VkDeviceMemory; 
          offset:                       VkDeviceSize; 
          size:                         VkDeviceSize; 
          flags:                        VkMemoryMapFlags; 
          ppData:                       PPVkVoid
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUnmapMemory = procedure(
          device:                       VkDevice; 
          memory:                       VkDeviceMemory
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFlushMappedMemoryRanges = function (
          device:                       VkDevice; 
          memoryRangeCount:             VkUint32; 
    const pMemoryRanges:                PVkMappedMemoryRange
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInvalidateMappedMemoryRanges = function (
          device:                       VkDevice; 
          memoryRangeCount:             VkUint32; 
    const pMemoryRanges:                PVkMappedMemoryRange
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceMemoryCommitment = procedure(
          device:                       VkDevice; 
          memory:                       VkDeviceMemory; 
          pCommittedMemoryInBytes:      PVkDeviceSize
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindBufferMemory = function (
          device:                       VkDevice; 
          buffer:                       VkBuffer; 
          memory:                       VkDeviceMemory; 
          memoryOffset:                 VkDeviceSize
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindImageMemory = function (
          device:                       VkDevice; 
          image:                        VkImage; 
          memory:                       VkDeviceMemory; 
          memoryOffset:                 VkDeviceSize
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetBufferMemoryRequirements = procedure(
          device:                       VkDevice; 
          buffer:                       VkBuffer; 
          pMemoryRequirements:          PVkMemoryRequirements
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageMemoryRequirements = procedure(
          device:                       VkDevice; 
          image:                        VkImage; 
          pMemoryRequirements:          PVkMemoryRequirements
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSparseMemoryRequirements = procedure(
          device:                       VkDevice; 
          image:                        VkImage; 
          pSparseMemoryRequirementCount:PVkUint32; 
          pSparseMemoryRequirements:    PVkSparseImageMemoryRequirements
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSparseImageFormatProperties = procedure(
          physicalDevice:               VkPhysicalDevice; 
          format:                       TVkFormat; 
          iType:                        TVkImageType; 
          samples:                      TVkSampleCountFlagBits; 
          usage:                        VkImageUsageFlags; 
          tiling:                       TVkImageTiling; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkSparseImageFormatProperties
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueBindSparse = function (
          queue:                        VkQueue; 
          bindInfoCount:                VkUint32; 
    const pBindInfo:                    PVkBindSparseInfo; 
          fence:                        VkFence
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFence = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkFenceCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pFence:                       PVkFence
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFence = procedure(
          device:                       VkDevice; 
          fence:                        VkFence; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetFences = function (
          device:                       VkDevice; 
          fenceCount:                   VkUint32; 
    const pFences:                      PVkFence
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetFenceStatus = function (
          device:                       VkDevice; 
          fence:                        VkFence
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkWaitForFences = function (
          device:                       VkDevice; 
          fenceCount:                   VkUint32; 
    const pFences:                      PVkFence; 
          waitAll:                      VkBool32; 
          timeout:                      VkUint64
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSemaphore = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkSemaphoreCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSemaphore:                   PVkSemaphore
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySemaphore = procedure(
          device:                       VkDevice; 
          semaphore:                    VkSemaphore; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateEvent = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkEventCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pEvent:                       PVkEvent
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyEvent = procedure(
          device:                       VkDevice; 
          event:                        VkEvent; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetEventStatus = function (
          device:                       VkDevice; 
          event:                        VkEvent
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkSetEvent = function (
          device:                       VkDevice; 
          event:                        VkEvent
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetEvent = function (
          device:                       VkDevice; 
          event:                        VkEvent
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateQueryPool = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkQueryPoolCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pQueryPool:                   PVkQueryPool
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyQueryPool = procedure(
          device:                       VkDevice; 
          queryPool:                    VkQueryPool; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetQueryPoolResults = function (
          device:                       VkDevice; 
          queryPool:                    VkQueryPool; 
          firstQuery:                   VkUint32; 
          queryCount:                   VkUint32; 
          dataSize:                     VkSize; 
          pData:                        PVkVoid; 
          stride:                       VkDeviceSize; 
          flags:                        VkQueryResultFlags
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBuffer = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkBufferCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pBuffer:                      PVkBuffer
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBuffer = procedure(
          device:                       VkDevice; 
          buffer:                       VkBuffer; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBufferView = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkBufferViewCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pView:                        PVkBufferView
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBufferView = procedure(
          device:                       VkDevice; 
          bufferView:                   VkBufferView; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImage = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkImageCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pImage:                       PVkImage
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImage = procedure(
          device:                       VkDevice; 
          image:                        VkImage; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSubresourceLayout = procedure(
          device:                       VkDevice; 
          image:                        VkImage; 
    const pSubresource:                 PVkImageSubresource; 
          pLayout:                      PVkSubresourceLayout
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImageView = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkImageViewCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pView:                        PVkImageView
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImageView = procedure(
          device:                       VkDevice; 
          imageView:                    VkImageView; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateShaderModule = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkShaderModuleCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pShaderModule:                PVkShaderModule
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyShaderModule = procedure(
          device:                       VkDevice; 
          shaderModule:                 VkShaderModule; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineCache = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkPipelineCacheCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pPipelineCache:               PVkPipelineCache
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineCache = procedure(
          device:                       VkDevice; 
          pipelineCache:                VkPipelineCache; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPipelineCacheData = function (
          device:                       VkDevice; 
          pipelineCache:                VkPipelineCache; 
          pDataSize:                    PVkSize; 
          pData:                        PVkVoid
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMergePipelineCaches = function (
          device:                       VkDevice; 
          dstCache:                     VkPipelineCache; 
          srcCacheCount:                VkUint32; 
    const pSrcCaches:                   PVkPipelineCache
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateGraphicsPipelines = function (
          device:                       VkDevice; 
          pipelineCache:                VkPipelineCache; 
          createInfoCount:              VkUint32; 
    const pCreateInfos:                 PVkGraphicsPipelineCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pPipelines:                   PVkPipeline
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateComputePipelines = function (
          device:                       VkDevice; 
          pipelineCache:                VkPipelineCache; 
          createInfoCount:              VkUint32; 
    const pCreateInfos:                 PVkComputePipelineCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pPipelines:                   PVkPipeline
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipeline = procedure(
          device:                       VkDevice; 
          pipeline:                     VkPipeline; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineLayout = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkPipelineLayoutCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pPipelineLayout:              PVkPipelineLayout
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineLayout = procedure(
          device:                       VkDevice; 
          pipelineLayout:               VkPipelineLayout; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSampler = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkSamplerCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSampler:                     PVkSampler
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySampler = procedure(
          device:                       VkDevice; 
          sampler:                      VkSampler; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorSetLayout = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkDescriptorSetLayoutCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSetLayout:                   PVkDescriptorSetLayout
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorSetLayout = procedure(
          device:                       VkDevice; 
          descriptorSetLayout:          VkDescriptorSetLayout; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorPool = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkDescriptorPoolCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pDescriptorPool:              PVkDescriptorPool
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorPool = procedure(
          device:                       VkDevice; 
          descriptorPool:               VkDescriptorPool; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetDescriptorPool = function (
          device:                       VkDevice; 
          descriptorPool:               VkDescriptorPool; 
          flags:                        VkDescriptorPoolResetFlags
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateDescriptorSets = function (
          device:                       VkDevice; 
    const pAllocateInfo:                PVkDescriptorSetAllocateInfo; 
          pDescriptorSets:              PVkDescriptorSet
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeDescriptorSets = function (
          device:                       VkDevice; 
          descriptorPool:               VkDescriptorPool; 
          descriptorSetCount:           VkUint32; 
    const pDescriptorSets:              PVkDescriptorSet
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUpdateDescriptorSets = procedure(
          device:                       VkDevice; 
          descriptorWriteCount:         VkUint32; 
    const pDescriptorWrites:            PVkWriteDescriptorSet; 
          descriptorCopyCount:          VkUint32; 
    const pDescriptorCopies:            PVkCopyDescriptorSet
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFramebuffer = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkFramebufferCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pFramebuffer:                 PVkFramebuffer
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFramebuffer = procedure(
          device:                       VkDevice; 
          framebuffer:                  VkFramebuffer; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateRenderPass = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkRenderPassCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pRenderPass:                  PVkRenderPass
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyRenderPass = procedure(
          device:                       VkDevice; 
          renderPass:                   VkRenderPass; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetRenderAreaGranularity = procedure(
          device:                       VkDevice; 
          renderPass:                   VkRenderPass; 
          pGranularity:                 PVkExtent2D
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateCommandPool = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkCommandPoolCreateInfo; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pCommandPool:                 PVkCommandPool
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyCommandPool = procedure(
          device:                       VkDevice; 
          commandPool:                  VkCommandPool; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandPool = function (
          device:                       VkDevice; 
          commandPool:                  VkCommandPool; 
          flags:                        VkCommandPoolResetFlags
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateCommandBuffers = function (
          device:                       VkDevice; 
    const pAllocateInfo:                PVkCommandBufferAllocateInfo; 
          pCommandBuffers:              PVkCommandBuffer
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeCommandBuffers = procedure(
          device:                       VkDevice; 
          commandPool:                  VkCommandPool; 
          commandBufferCount:           VkUint32; 
    const pCommandBuffers:              PVkCommandBuffer
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBeginCommandBuffer = function (
          commandBuffer:                VkCommandBuffer; 
    const pBeginInfo:                   PVkCommandBufferBeginInfo
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEndCommandBuffer = function (
          commandBuffer:                VkCommandBuffer
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandBuffer = function (
          commandBuffer:                VkCommandBuffer; 
          flags:                        VkCommandBufferResetFlags
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindPipeline = procedure(
          commandBuffer:                VkCommandBuffer; 
          pipelineBindPoint:            TVkPipelineBindPoint; 
          pipeline:                     VkPipeline
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetViewport = procedure(
          commandBuffer:                VkCommandBuffer; 
          firstViewport:                VkUint32; 
          viewportCount:                VkUint32; 
    const pViewports:                   PVkViewport
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetScissor = procedure(
          commandBuffer:                VkCommandBuffer; 
          firstScissor:                 VkUint32; 
          scissorCount:                 VkUint32; 
    const pScissors:                    PVkRect2D
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetLineWidth = procedure(
          commandBuffer:                VkCommandBuffer; 
          lineWidth:                    VkFloat
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBias = procedure(
          commandBuffer:                VkCommandBuffer; 
          depthBiasConstantFactor:      VkFloat; 
          depthBiasClamp:               VkFloat; 
          depthBiasSlopeFactor:         VkFloat
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetBlendConstants = procedure(
          commandBuffer:                VkCommandBuffer; 
    const blendConstants:               VkFloat
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBounds = procedure(
          commandBuffer:                VkCommandBuffer; 
          minDepthBounds:               VkFloat; 
          maxDepthBounds:               VkFloat
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilCompareMask = procedure(
          commandBuffer:                VkCommandBuffer; 
          faceMask:                     VkStencilFaceFlags; 
          compareMask:                  VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilWriteMask = procedure(
          commandBuffer:                VkCommandBuffer; 
          faceMask:                     VkStencilFaceFlags; 
          writeMask:                    VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilReference = procedure(
          commandBuffer:                VkCommandBuffer; 
          faceMask:                     VkStencilFaceFlags; 
          reference:                    VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindDescriptorSets = procedure(
          commandBuffer:                VkCommandBuffer; 
          pipelineBindPoint:            TVkPipelineBindPoint; 
          layout:                       VkPipelineLayout; 
          firstSet:                     VkUint32; 
          descriptorSetCount:           VkUint32; 
    const pDescriptorSets:              PVkDescriptorSet; 
          dynamicOffsetCount:           VkUint32; 
    const pDynamicOffsets:              PVkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindIndexBuffer = procedure(
          commandBuffer:                VkCommandBuffer; 
          buffer:                       VkBuffer; 
          offset:                       VkDeviceSize; 
          indexType:                    TVkIndexType
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindVertexBuffers = procedure(
          commandBuffer:                VkCommandBuffer; 
          firstBinding:                 VkUint32; 
          bindingCount:                 VkUint32; 
    const pBuffers:                     PVkBuffer; 
    const pOffsets:                     PVkDeviceSize
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDraw = procedure(
          commandBuffer:                VkCommandBuffer; 
          vertexCount:                  VkUint32; 
          instanceCount:                VkUint32; 
          firstVertex:                  VkUint32; 
          firstInstance:                VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexed = procedure(
          commandBuffer:                VkCommandBuffer; 
          indexCount:                   VkUint32; 
          instanceCount:                VkUint32; 
          firstIndex:                   VkUint32; 
          vertexOffset:                 VkInt32; 
          firstInstance:                VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndirect = procedure(
          commandBuffer:                VkCommandBuffer; 
          buffer:                       VkBuffer; 
          offset:                       VkDeviceSize; 
          drawCount:                    VkUint32; 
          stride:                       VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexedIndirect = procedure(
          commandBuffer:                VkCommandBuffer; 
          buffer:                       VkBuffer; 
          offset:                       VkDeviceSize; 
          drawCount:                    VkUint32; 
          stride:                       VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatch = procedure(
          commandBuffer:                VkCommandBuffer; 
          x:                            VkUint32; 
          y:                            VkUint32; 
          z:                            VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatchIndirect = procedure(
          commandBuffer:                VkCommandBuffer; 
          buffer:                       VkBuffer; 
          offset:                       VkDeviceSize
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBuffer = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcBuffer:                    VkBuffer; 
          dstBuffer:                    VkBuffer; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkBufferCopy
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcImage:                     VkImage; 
          srcImageLayout:               TVkImageLayout; 
          dstImage:                     VkImage; 
          dstImageLayout:               TVkImageLayout; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkImageCopy
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBlitImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcImage:                     VkImage; 
          srcImageLayout:               TVkImageLayout; 
          dstImage:                     VkImage; 
          dstImageLayout:               TVkImageLayout; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkImageBlit; 
          filter:                       TVkFilter
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBufferToImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcBuffer:                    VkBuffer; 
          dstImage:                     VkImage; 
          dstImageLayout:               TVkImageLayout; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkBufferImageCopy
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImageToBuffer = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcImage:                     VkImage; 
          srcImageLayout:               TVkImageLayout; 
          dstBuffer:                    VkBuffer; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkBufferImageCopy
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdUpdateBuffer = procedure(
          commandBuffer:                VkCommandBuffer; 
          dstBuffer:                    VkBuffer; 
          dstOffset:                    VkDeviceSize; 
          dataSize:                     VkDeviceSize; 
    const pData:                        PVkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdFillBuffer = procedure(
          commandBuffer:                VkCommandBuffer; 
          dstBuffer:                    VkBuffer; 
          dstOffset:                    VkDeviceSize; 
          size:                         VkDeviceSize; 
          data:                         VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearColorImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          image:                        VkImage; 
          imageLayout:                  TVkImageLayout; 
    const pColor:                       PVkClearColorValue; 
          rangeCount:                   VkUint32; 
    const pRanges:                      PVkImageSubresourceRange
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearDepthStencilImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          image:                        VkImage; 
          imageLayout:                  TVkImageLayout; 
    const pDepthStencil:                PVkClearDepthStencilValue; 
          rangeCount:                   VkUint32; 
    const pRanges:                      PVkImageSubresourceRange
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearAttachments = procedure(
          commandBuffer:                VkCommandBuffer; 
          attachmentCount:              VkUint32; 
    const pAttachments:                 PVkClearAttachment; 
          rectCount:                    VkUint32; 
    const pRects:                       PVkClearRect
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResolveImage = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcImage:                     VkImage; 
          srcImageLayout:               TVkImageLayout; 
          dstImage:                     VkImage; 
          dstImageLayout:               TVkImageLayout; 
          regionCount:                  VkUint32; 
    const pRegions:                     PVkImageResolve
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetEvent = procedure(
          commandBuffer:                VkCommandBuffer; 
          event:                        VkEvent; 
          stageMask:                    VkPipelineStageFlags
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetEvent = procedure(
          commandBuffer:                VkCommandBuffer; 
          event:                        VkEvent; 
          stageMask:                    VkPipelineStageFlags
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWaitEvents = procedure(
          commandBuffer:                VkCommandBuffer; 
          eventCount:                   VkUint32; 
    const pEvents:                      PVkEvent; 
          srcStageMask:                 VkPipelineStageFlags; 
          dstStageMask:                 VkPipelineStageFlags; 
          memoryBarrierCount:           VkUint32; 
    const pMemoryBarriers:              PVkMemoryBarrier; 
          bufferMemoryBarrierCount:     VkUint32; 
    const pBufferMemoryBarriers:        PVkBufferMemoryBarrier; 
          imageMemoryBarrierCount:      VkUint32; 
    const pImageMemoryBarriers:         PVkImageMemoryBarrier
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPipelineBarrier = procedure(
          commandBuffer:                VkCommandBuffer; 
          srcStageMask:                 VkPipelineStageFlags; 
          dstStageMask:                 VkPipelineStageFlags; 
          dependencyFlags:              VkDependencyFlags; 
          memoryBarrierCount:           VkUint32; 
    const pMemoryBarriers:              PVkMemoryBarrier; 
          bufferMemoryBarrierCount:     VkUint32; 
    const pBufferMemoryBarriers:        PVkBufferMemoryBarrier; 
          imageMemoryBarrierCount:      VkUint32; 
    const pImageMemoryBarriers:         PVkImageMemoryBarrier
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginQuery = procedure(
          commandBuffer:                VkCommandBuffer; 
          queryPool:                    VkQueryPool; 
          query:                        VkUint32; 
          flags:                        VkQueryControlFlags
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndQuery = procedure(
          commandBuffer:                VkCommandBuffer; 
          queryPool:                    VkQueryPool; 
          query:                        VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetQueryPool = procedure(
          commandBuffer:                VkCommandBuffer; 
          queryPool:                    VkQueryPool; 
          firstQuery:                   VkUint32; 
          queryCount:                   VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWriteTimestamp = procedure(
          commandBuffer:                VkCommandBuffer; 
          pipelineStage:                TVkPipelineStageFlagBits; 
          queryPool:                    VkQueryPool; 
          query:                        VkUint32
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyQueryPoolResults = procedure(
          commandBuffer:                VkCommandBuffer; 
          queryPool:                    VkQueryPool; 
          firstQuery:                   VkUint32; 
          queryCount:                   VkUint32; 
          dstBuffer:                    VkBuffer; 
          dstOffset:                    VkDeviceSize; 
          stride:                       VkDeviceSize; 
          flags:                        VkQueryResultFlags
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPushConstants = procedure(
          commandBuffer:                VkCommandBuffer; 
          layout:                       VkPipelineLayout; 
          stageFlags:                   VkShaderStageFlags; 
          offset:                       VkUint32; 
          size:                         VkUint32; 
    const pValues:                      PVkVoid
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginRenderPass = procedure(
          commandBuffer:                VkCommandBuffer; 
    const pRenderPassBegin:             PVkRenderPassBeginInfo; 
          contents:                     TVkSubpassContents
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdNextSubpass = procedure(
          commandBuffer:                VkCommandBuffer; 
          contents:                     TVkSubpassContents
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndRenderPass = procedure(
          commandBuffer:                VkCommandBuffer
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdExecuteCommands = procedure(
          commandBuffer:                VkCommandBuffer; 
          commandBufferCount:           VkUint32; 
    const pCommandBuffers:              PVkCommandBuffer
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ========================================== VK_KHR_surface ========================================== }
  TvkDestroySurfaceKHR = procedure(
          instance:                     VkInstance; 
          surface:                      VkSurfaceKHR; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32; 
          surface:                      VkSurfaceKHR; 
          pSupported:                   PVkBool32
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceCapabilitiesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          surface:                      VkSurfaceKHR; 
          pSurfaceCapabilities:         PVkSurfaceCapabilitiesKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceFormatsKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          surface:                      VkSurfaceKHR; 
          pSurfaceFormatCount:          PVkUint32; 
          pSurfaceFormats:              PVkSurfaceFormatKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfacePresentModesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          surface:                      VkSurfaceKHR; 
          pPresentModeCount:            PVkUint32; 
          pPresentModes:                PVkPresentModeKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ========================================= VK_KHR_swapchain ========================================= }
  TvkCreateSwapchainKHR = function (
          device:                       VkDevice; 
    const pCreateInfo:                  PVkSwapchainCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSwapchain:                   PVkSwapchainKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySwapchainKHR = procedure(
          device:                       VkDevice; 
          swapchain:                    VkSwapchainKHR; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetSwapchainImagesKHR = function (
          device:                       VkDevice; 
          swapchain:                    VkSwapchainKHR; 
          pSwapchainImageCount:         PVkUint32; 
          pSwapchainImages:             PVkImage
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAcquireNextImageKHR = function (
          device:                       VkDevice; 
          swapchain:                    VkSwapchainKHR; 
          timeout:                      VkUint64; 
          semaphore:                    VkSemaphore; 
          fence:                        VkFence; 
          pImageIndex:                  PVkUint32
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueuePresentKHR = function (
          queue:                        VkQueue; 
    const pPresentInfo:                 PVkPresentInfoKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ========================================== VK_KHR_display ========================================== }
  TvkGetPhysicalDeviceDisplayPropertiesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkDisplayPropertiesKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceDisplayPlanePropertiesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkDisplayPlanePropertiesKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneSupportedDisplaysKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          planeIndex:                   VkUint32; 
          pDisplayCount:                PVkUint32; 
          pDisplays:                    PVkDisplayKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayModePropertiesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          display:                      VkDisplayKHR; 
          pPropertyCount:               PVkUint32; 
          pProperties:                  PVkDisplayModePropertiesKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayModeKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          display:                      VkDisplayKHR; 
    const pCreateInfo:                  PVkDisplayModeCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pMode:                        PVkDisplayModeKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneCapabilitiesKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          mode:                         VkDisplayModeKHR; 
          planeIndex:                   VkUint32; 
          pCapabilities:                PVkDisplayPlaneCapabilitiesKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayPlaneSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkDisplaySurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ===================================== VK_KHR_display_swapchain ===================================== }
  TvkCreateSharedSwapchainsKHR = function (
          device:                       VkDevice; 
          swapchainCount:               VkUint32; 
    const pCreateInfos:                 PVkSwapchainCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSwapchains:                  PVkSwapchainKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{ ======================================= VK_KHR_xlib_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  TvkCreateXlibSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkXlibSurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceXlibPresentationSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32; 
          dpy:                          Display; 
          visualID:                     VisualID
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ======================================== VK_KHR_xcb_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  TvkCreateXcbSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkXcbSurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceXcbPresentationSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32; 
          connection:                   xcb_connection_t; 
          visual_id:                    xcb_visualid_t
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ====================================== VK_KHR_wayland_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  TvkCreateWaylandSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkWaylandSurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceWaylandPresentationSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32; 
          display:                      wl_display
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ======================================== VK_KHR_mir_surface ======================================== }
{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  TvkCreateMirSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkMirSurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMirPresentationSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32; 
          connection:                   MirConnection
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ====================================== VK_KHR_android_surface ====================================== }
{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  TvkCreateAndroidSurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkAndroidSurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ======================================= VK_KHR_win32_surface ======================================= }
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TvkCreateWin32SurfaceKHR = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkWin32SurfaceCreateInfoKHR; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pSurface:                     PVkSurfaceKHR
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceWin32PresentationSupportKHR = function (
          physicalDevice:               VkPhysicalDevice; 
          queueFamilyIndex:             VkUint32
  ): VkBool32; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF}

{ ======================================= VK_EXT_debug_report ======================================== }
  TvkCreateDebugReportCallbackEXT = function (
          instance:                     VkInstance; 
    const pCreateInfo:                  PVkDebugReportCallbackCreateInfoEXT; 
    const pAllocator:                   PVkAllocationCallbacks; 
          pCallback:                    PVkDebugReportCallbackEXT
  ): TVkResult; {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDebugReportCallbackEXT = procedure(
          instance:                     VkInstance; 
          callback:                     VkDebugReportCallbackEXT; 
    const pAllocator:                   PVkAllocationCallbacks
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDebugReportMessageEXT = procedure(
          instance:                     VkInstance; 
          flags:                        VkDebugReportFlagsEXT; 
          objectType:                   TVkDebugReportObjectTypeEXT; 
          uObject:                      VkUint64; 
          location:                     VkSize; 
          messageCode:                  VkInt32; 
    const pLayerPrefix:                 PVkChar; 
    const pMessage:                     PVkChar
  ); {$IFDEF VK_CDECL}cdecl{$ELSE}stdcall{$ENDIF};

var

{ ========================================== VK_VERSION_1_0 ========================================== }
  vkCreateInstance:                                 TvkCreateInstance;
  vkGetInstanceProcAddr:                            TvkGetInstanceProcAddr;
  vkEnumerateInstanceExtensionProperties:           TvkEnumerateInstanceExtensionProperties;
  vkEnumerateInstanceLayerProperties:               TvkEnumerateInstanceLayerProperties;

const { predefined flags / sets }
  VK_SHADER_STAGE_ALL_GRAPHICS: TVkShaderStageFlagBits = [
    VK_SHADER_STAGE_VERTEX_BIT,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    VK_SHADER_STAGE_GEOMETRY_BIT,
    VK_SHADER_STAGE_FRAGMENT_BIT
  ];
  VK_SHADER_STAGE_ALL: TVkShaderStageFlagBits = [
    VK_SHADER_STAGE_VERTEX_BIT,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    VK_SHADER_STAGE_GEOMETRY_BIT,
    VK_SHADER_STAGE_FRAGMENT_BIT,
    VK_SHADER_STAGE_COMPUTE_BIT
  ];
  VK_CULL_MODE_NONE: TVkCullModeFlagBits = [  ];
  VK_CULL_MODE_FRONT_AND_BACK: TVkCullModeFlagBits = [
    VK_CULL_MODE_FRONT_BIT,
    VK_CULL_MODE_BACK_BIT
  ];
  VK_STENCIL_FRONT_AND_BACK: TVkStencilFaceFlagBits = [
    VK_STENCIL_FACE_FRONT_BIT,
    VK_STENCIL_FACE_BACK_BIT
  ];

type
  TVkInstanceCommands = class
    Instance: VkInstance;
    
    { ========================================== VK_VERSION_1_0 ========================================== }
    vkDestroyInstance:                                TvkDestroyInstance;
    vkEnumeratePhysicalDevices:                       TvkEnumeratePhysicalDevices;
    vkGetPhysicalDeviceFeatures:                      TvkGetPhysicalDeviceFeatures;
    vkGetPhysicalDeviceFormatProperties:              TvkGetPhysicalDeviceFormatProperties;
    vkGetPhysicalDeviceImageFormatProperties:         TvkGetPhysicalDeviceImageFormatProperties;
    vkGetPhysicalDeviceProperties:                    TvkGetPhysicalDeviceProperties;
    vkGetPhysicalDeviceQueueFamilyProperties:         TvkGetPhysicalDeviceQueueFamilyProperties;
    vkGetPhysicalDeviceMemoryProperties:              TvkGetPhysicalDeviceMemoryProperties;
    vkGetDeviceProcAddr:                              TvkGetDeviceProcAddr;
    vkCreateDevice:                                   TvkCreateDevice;
    vkEnumerateDeviceExtensionProperties:             TvkEnumerateDeviceExtensionProperties;
    vkEnumerateDeviceLayerProperties:                 TvkEnumerateDeviceLayerProperties;
    vkGetPhysicalDeviceSparseImageFormatProperties:   TvkGetPhysicalDeviceSparseImageFormatProperties;
    
    { ========================================== VK_KHR_surface ========================================== }
    vkDestroySurfaceKHR:                              TvkDestroySurfaceKHR;
    vkGetPhysicalDeviceSurfaceSupportKHR:             TvkGetPhysicalDeviceSurfaceSupportKHR;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR:        TvkGetPhysicalDeviceSurfaceCapabilitiesKHR;
    vkGetPhysicalDeviceSurfaceFormatsKHR:             TvkGetPhysicalDeviceSurfaceFormatsKHR;
    vkGetPhysicalDeviceSurfacePresentModesKHR:        TvkGetPhysicalDeviceSurfacePresentModesKHR;
    
    { ========================================== VK_KHR_display ========================================== }
    vkGetPhysicalDeviceDisplayPropertiesKHR:          TvkGetPhysicalDeviceDisplayPropertiesKHR;
    vkGetPhysicalDeviceDisplayPlanePropertiesKHR:     TvkGetPhysicalDeviceDisplayPlanePropertiesKHR;
    vkGetDisplayPlaneSupportedDisplaysKHR:            TvkGetDisplayPlaneSupportedDisplaysKHR;
    vkGetDisplayModePropertiesKHR:                    TvkGetDisplayModePropertiesKHR;
    vkCreateDisplayModeKHR:                           TvkCreateDisplayModeKHR;
    vkGetDisplayPlaneCapabilitiesKHR:                 TvkGetDisplayPlaneCapabilitiesKHR;
    vkCreateDisplayPlaneSurfaceKHR:                   TvkCreateDisplayPlaneSurfaceKHR;
    
    { ======================================= VK_KHR_xlib_surface ======================================== }
    {$IFDEF VK_USE_PLATFORM_XLIB_KHR}
    vkCreateXlibSurfaceKHR:                           TvkCreateXlibSurfaceKHR;
    vkGetPhysicalDeviceXlibPresentationSupportKHR:    TvkGetPhysicalDeviceXlibPresentationSupportKHR;
    {$ENDIF}
    
    { ======================================== VK_KHR_xcb_surface ======================================== }
    {$IFDEF VK_USE_PLATFORM_XCB_KHR}
    vkCreateXcbSurfaceKHR:                            TvkCreateXcbSurfaceKHR;
    vkGetPhysicalDeviceXcbPresentationSupportKHR:     TvkGetPhysicalDeviceXcbPresentationSupportKHR;
    {$ENDIF}
    
    { ====================================== VK_KHR_wayland_surface ====================================== }
    {$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
    vkCreateWaylandSurfaceKHR:                        TvkCreateWaylandSurfaceKHR;
    vkGetPhysicalDeviceWaylandPresentationSupportKHR: TvkGetPhysicalDeviceWaylandPresentationSupportKHR;
    {$ENDIF}
    
    { ======================================== VK_KHR_mir_surface ======================================== }
    {$IFDEF VK_USE_PLATFORM_MIR_KHR}
    vkCreateMirSurfaceKHR:                            TvkCreateMirSurfaceKHR;
    vkGetPhysicalDeviceMirPresentationSupportKHR:     TvkGetPhysicalDeviceMirPresentationSupportKHR;
    {$ENDIF}
    
    { ====================================== VK_KHR_android_surface ====================================== }
    {$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
    vkCreateAndroidSurfaceKHR:                        TvkCreateAndroidSurfaceKHR;
    {$ENDIF}
    
    { ======================================= VK_KHR_win32_surface ======================================= }
    {$IFDEF VK_USE_PLATFORM_WIN32_KHR}
    vkCreateWin32SurfaceKHR:                          TvkCreateWin32SurfaceKHR;
    vkGetPhysicalDeviceWin32PresentationSupportKHR:   TvkGetPhysicalDeviceWin32PresentationSupportKHR;
    {$ENDIF}
    
    { ======================================= VK_EXT_debug_report ======================================== }
    vkCreateDebugReportCallbackEXT:                   TvkCreateDebugReportCallbackEXT;
    vkDestroyDebugReportCallbackEXT:                  TvkDestroyDebugReportCallbackEXT;
    vkDebugReportMessageEXT:                          TvkDebugReportMessageEXT;

  end;

  TVkDeviceCommands = class
    Device: VkDevice;
    
    { ========================================== VK_VERSION_1_0 ========================================== }
    vkDestroyDevice:                                  TvkDestroyDevice;
    vkGetDeviceQueue:                                 TvkGetDeviceQueue;
    vkQueueSubmit:                                    TvkQueueSubmit;
    vkQueueWaitIdle:                                  TvkQueueWaitIdle;
    vkDeviceWaitIdle:                                 TvkDeviceWaitIdle;
    vkAllocateMemory:                                 TvkAllocateMemory;
    vkFreeMemory:                                     TvkFreeMemory;
    vkMapMemory:                                      TvkMapMemory;
    vkUnmapMemory:                                    TvkUnmapMemory;
    vkFlushMappedMemoryRanges:                        TvkFlushMappedMemoryRanges;
    vkInvalidateMappedMemoryRanges:                   TvkInvalidateMappedMemoryRanges;
    vkGetDeviceMemoryCommitment:                      TvkGetDeviceMemoryCommitment;
    vkBindBufferMemory:                               TvkBindBufferMemory;
    vkBindImageMemory:                                TvkBindImageMemory;
    vkGetBufferMemoryRequirements:                    TvkGetBufferMemoryRequirements;
    vkGetImageMemoryRequirements:                     TvkGetImageMemoryRequirements;
    vkGetImageSparseMemoryRequirements:               TvkGetImageSparseMemoryRequirements;
    vkQueueBindSparse:                                TvkQueueBindSparse;
    vkCreateFence:                                    TvkCreateFence;
    vkDestroyFence:                                   TvkDestroyFence;
    vkResetFences:                                    TvkResetFences;
    vkGetFenceStatus:                                 TvkGetFenceStatus;
    vkWaitForFences:                                  TvkWaitForFences;
    vkCreateSemaphore:                                TvkCreateSemaphore;
    vkDestroySemaphore:                               TvkDestroySemaphore;
    vkCreateEvent:                                    TvkCreateEvent;
    vkDestroyEvent:                                   TvkDestroyEvent;
    vkGetEventStatus:                                 TvkGetEventStatus;
    vkSetEvent:                                       TvkSetEvent;
    vkResetEvent:                                     TvkResetEvent;
    vkCreateQueryPool:                                TvkCreateQueryPool;
    vkDestroyQueryPool:                               TvkDestroyQueryPool;
    vkGetQueryPoolResults:                            TvkGetQueryPoolResults;
    vkCreateBuffer:                                   TvkCreateBuffer;
    vkDestroyBuffer:                                  TvkDestroyBuffer;
    vkCreateBufferView:                               TvkCreateBufferView;
    vkDestroyBufferView:                              TvkDestroyBufferView;
    vkCreateImage:                                    TvkCreateImage;
    vkDestroyImage:                                   TvkDestroyImage;
    vkGetImageSubresourceLayout:                      TvkGetImageSubresourceLayout;
    vkCreateImageView:                                TvkCreateImageView;
    vkDestroyImageView:                               TvkDestroyImageView;
    vkCreateShaderModule:                             TvkCreateShaderModule;
    vkDestroyShaderModule:                            TvkDestroyShaderModule;
    vkCreatePipelineCache:                            TvkCreatePipelineCache;
    vkDestroyPipelineCache:                           TvkDestroyPipelineCache;
    vkGetPipelineCacheData:                           TvkGetPipelineCacheData;
    vkMergePipelineCaches:                            TvkMergePipelineCaches;
    vkCreateGraphicsPipelines:                        TvkCreateGraphicsPipelines;
    vkCreateComputePipelines:                         TvkCreateComputePipelines;
    vkDestroyPipeline:                                TvkDestroyPipeline;
    vkCreatePipelineLayout:                           TvkCreatePipelineLayout;
    vkDestroyPipelineLayout:                          TvkDestroyPipelineLayout;
    vkCreateSampler:                                  TvkCreateSampler;
    vkDestroySampler:                                 TvkDestroySampler;
    vkCreateDescriptorSetLayout:                      TvkCreateDescriptorSetLayout;
    vkDestroyDescriptorSetLayout:                     TvkDestroyDescriptorSetLayout;
    vkCreateDescriptorPool:                           TvkCreateDescriptorPool;
    vkDestroyDescriptorPool:                          TvkDestroyDescriptorPool;
    vkResetDescriptorPool:                            TvkResetDescriptorPool;
    vkAllocateDescriptorSets:                         TvkAllocateDescriptorSets;
    vkFreeDescriptorSets:                             TvkFreeDescriptorSets;
    vkUpdateDescriptorSets:                           TvkUpdateDescriptorSets;
    vkCreateFramebuffer:                              TvkCreateFramebuffer;
    vkDestroyFramebuffer:                             TvkDestroyFramebuffer;
    vkCreateRenderPass:                               TvkCreateRenderPass;
    vkDestroyRenderPass:                              TvkDestroyRenderPass;
    vkGetRenderAreaGranularity:                       TvkGetRenderAreaGranularity;
    vkCreateCommandPool:                              TvkCreateCommandPool;
    vkDestroyCommandPool:                             TvkDestroyCommandPool;
    vkResetCommandPool:                               TvkResetCommandPool;
    vkAllocateCommandBuffers:                         TvkAllocateCommandBuffers;
    vkFreeCommandBuffers:                             TvkFreeCommandBuffers;
    vkBeginCommandBuffer:                             TvkBeginCommandBuffer;
    vkEndCommandBuffer:                               TvkEndCommandBuffer;
    vkResetCommandBuffer:                             TvkResetCommandBuffer;
    vkCmdBindPipeline:                                TvkCmdBindPipeline;
    vkCmdSetViewport:                                 TvkCmdSetViewport;
    vkCmdSetScissor:                                  TvkCmdSetScissor;
    vkCmdSetLineWidth:                                TvkCmdSetLineWidth;
    vkCmdSetDepthBias:                                TvkCmdSetDepthBias;
    vkCmdSetBlendConstants:                           TvkCmdSetBlendConstants;
    vkCmdSetDepthBounds:                              TvkCmdSetDepthBounds;
    vkCmdSetStencilCompareMask:                       TvkCmdSetStencilCompareMask;
    vkCmdSetStencilWriteMask:                         TvkCmdSetStencilWriteMask;
    vkCmdSetStencilReference:                         TvkCmdSetStencilReference;
    vkCmdBindDescriptorSets:                          TvkCmdBindDescriptorSets;
    vkCmdBindIndexBuffer:                             TvkCmdBindIndexBuffer;
    vkCmdBindVertexBuffers:                           TvkCmdBindVertexBuffers;
    vkCmdDraw:                                        TvkCmdDraw;
    vkCmdDrawIndexed:                                 TvkCmdDrawIndexed;
    vkCmdDrawIndirect:                                TvkCmdDrawIndirect;
    vkCmdDrawIndexedIndirect:                         TvkCmdDrawIndexedIndirect;
    vkCmdDispatch:                                    TvkCmdDispatch;
    vkCmdDispatchIndirect:                            TvkCmdDispatchIndirect;
    vkCmdCopyBuffer:                                  TvkCmdCopyBuffer;
    vkCmdCopyImage:                                   TvkCmdCopyImage;
    vkCmdBlitImage:                                   TvkCmdBlitImage;
    vkCmdCopyBufferToImage:                           TvkCmdCopyBufferToImage;
    vkCmdCopyImageToBuffer:                           TvkCmdCopyImageToBuffer;
    vkCmdUpdateBuffer:                                TvkCmdUpdateBuffer;
    vkCmdFillBuffer:                                  TvkCmdFillBuffer;
    vkCmdClearColorImage:                             TvkCmdClearColorImage;
    vkCmdClearDepthStencilImage:                      TvkCmdClearDepthStencilImage;
    vkCmdClearAttachments:                            TvkCmdClearAttachments;
    vkCmdResolveImage:                                TvkCmdResolveImage;
    vkCmdSetEvent:                                    TvkCmdSetEvent;
    vkCmdResetEvent:                                  TvkCmdResetEvent;
    vkCmdWaitEvents:                                  TvkCmdWaitEvents;
    vkCmdPipelineBarrier:                             TvkCmdPipelineBarrier;
    vkCmdBeginQuery:                                  TvkCmdBeginQuery;
    vkCmdEndQuery:                                    TvkCmdEndQuery;
    vkCmdResetQueryPool:                              TvkCmdResetQueryPool;
    vkCmdWriteTimestamp:                              TvkCmdWriteTimestamp;
    vkCmdCopyQueryPoolResults:                        TvkCmdCopyQueryPoolResults;
    vkCmdPushConstants:                               TvkCmdPushConstants;
    vkCmdBeginRenderPass:                             TvkCmdBeginRenderPass;
    vkCmdNextSubpass:                                 TvkCmdNextSubpass;
    vkCmdEndRenderPass:                               TvkCmdEndRenderPass;
    vkCmdExecuteCommands:                             TvkCmdExecuteCommands;
    
    { ========================================= VK_KHR_swapchain ========================================= }
    vkCreateSwapchainKHR:                             TvkCreateSwapchainKHR;
    vkDestroySwapchainKHR:                            TvkDestroySwapchainKHR;
    vkGetSwapchainImagesKHR:                          TvkGetSwapchainImagesKHR;
    vkAcquireNextImageKHR:                            TvkAcquireNextImageKHR;
    vkQueuePresentKHR:                                TvkQueuePresentKHR;
    
    { ===================================== VK_KHR_display_swapchain ===================================== }
    vkCreateSharedSwapchainsKHR:                      TvkCreateSharedSwapchainsKHR;

  end;

const
  VULKAN_LIBNAME = 'vulkan-1.dll';

type
  VkVersion = VkInt32;

function vkMakeVersion(const aMajor, aMinor, aPatch: Integer): VkVersion; inline;
function vkGetVersionMajor(const aVersion: VkVersion): Integer; inline;
function vkGetVersionMinor(const aVersion: VkVersion): Integer; inline;
function vkGetVersionPatch(const aVersion: VkVersion): Integer; inline;

function  InitializeVulkan(const aLibName: String = VULKAN_LIBNAME): Boolean;
function  LoadInstanceCommands(const aInstance: VkInstance): TVkInstanceCommands;
function  LoadDeviceCommands(const aInstance: VkInstance; const aDevice: VkDevice): TVkDeviceCommands;
procedure FinalizeVulkan;

implementation

uses
  SysUtils;

type
{$IF DEFINED(VK_WIN)}
  TvkLibHandle = TLibHandle;
{$ELSE}
  TvkLibHandle = Pointer;
{$ENDIF}

const
{$IF DEFINED(VK_WIN)}
  InvalidLibHandle = 0;
{$ELSE}
  InvalidLibHandle = nil;
{$ENDIF}

var
  vkLibHandle: TvkLibHandle = InvalidLibHandle;

{ ===================================== Library Handling ============================================= }
function vkLoadLibrary(const aLibName: String): TvkLibHandle;
begin
  {$IF DEFINED(VK_WIN)}
  result := LoadLibrary(aLibName);
  {$ELSE}
  result := InvalidLibHandle;
  {$ENDIF}
end;

function vkGetProcAddress(const aProcName: String; aLibHandle: TvkLibHandle = InvalidLibHandle): TvkVoidFunction;
begin
  result := nil;
  if (aLibHandle = InvalidLibHandle) then
    aLibHandle := vkLibHandle;
  {$IF DEFINED(VK_WIN)}
  result := TvkVoidFunction(GetProcAddress(aLibHandle, AnsiString(aProcName)));
  {$ELSE}
  result := nil;
  {$ENDIF}
end;

procedure vkFreeLibrary(var aLibHandle: TvkLibHandle);
begin
  if (aLibHandle <> InvalidLibHandle) then begin
    {$IF DEFINED(VK_WIN)}
    FreeLibrary(aLibHandle);
    {$ENDIF}
    aLibHandle := InvalidLibHandle;
  end;
end;

{ ===================================== Vulkan Version Helpers ======================================= }
function vkMakeVersion(const aMajor, aMinor, aPatch: Integer): VkVersion;
begin
  result := (aMajor shl 22) or (aMinor shl 12) or aPatch;
end;

function vkGetVersionMajor(const aVersion: VkVersion): Integer;
begin
  result := (aVersion shr 22);
end;

function vkGetVersionMinor(const aVersion: VkVersion): Integer;
begin
  result := (aVersion shr 12) and $3FF;
end;

function vkGetVersionPatch(const aVersion: VkVersion): Integer;
begin
  result := (aVersion and $FFF);
end;

{ ===================================== Initialize Routines ========================================== }
function InitializeVulkan(const aLibName: String = VULKAN_LIBNAME): Boolean;
var success: Boolean;

  function GetProcAddress(const aName: String): TvkVoidFunction;
  begin
    result := vkGetProcAddress(aName);
    if not Assigned(result) then
      success := false;
  end;

begin
  FinalizeVulkan;
  vkLibHandle := vkLoadLibrary(aLibName);
  result := (vkLibHandle <> InvalidLibHandle);
  if not result then
    exit;
  
  vkCreateInstance                                   := TvkCreateInstance                                  (GetProcAddress('vkCreateInstance'));
  vkGetInstanceProcAddr                              := TvkGetInstanceProcAddr                             (GetProcAddress('vkGetInstanceProcAddr'));
  vkEnumerateInstanceExtensionProperties             := TvkEnumerateInstanceExtensionProperties            (GetProcAddress('vkEnumerateInstanceExtensionProperties'));
  vkEnumerateInstanceLayerProperties                 := TvkEnumerateInstanceLayerProperties                (GetProcAddress('vkEnumerateInstanceLayerProperties'));
end;

function LoadInstanceCommands(const aInstance: VkInstance): TVkInstanceCommands;

  function GetProcAddress(const aName: String): TvkVoidFunction;
  begin
    result := vkGetInstanceProcAddr(aInstance, PVkChar(aName));
  end;

begin
  result  := TVkInstanceCommands.Create;
  try
    result.Instance := aInstance;
    with result do begin
      
      { ========================================== VK_VERSION_1_0 ========================================== }
      vkDestroyInstance                                  := TvkDestroyInstance                                 (GetProcAddress('vkDestroyInstance'));
      vkEnumeratePhysicalDevices                         := TvkEnumeratePhysicalDevices                        (GetProcAddress('vkEnumeratePhysicalDevices'));
      vkGetPhysicalDeviceFeatures                        := TvkGetPhysicalDeviceFeatures                       (GetProcAddress('vkGetPhysicalDeviceFeatures'));
      vkGetPhysicalDeviceFormatProperties                := TvkGetPhysicalDeviceFormatProperties               (GetProcAddress('vkGetPhysicalDeviceFormatProperties'));
      vkGetPhysicalDeviceImageFormatProperties           := TvkGetPhysicalDeviceImageFormatProperties          (GetProcAddress('vkGetPhysicalDeviceImageFormatProperties'));
      vkGetPhysicalDeviceProperties                      := TvkGetPhysicalDeviceProperties                     (GetProcAddress('vkGetPhysicalDeviceProperties'));
      vkGetPhysicalDeviceQueueFamilyProperties           := TvkGetPhysicalDeviceQueueFamilyProperties          (GetProcAddress('vkGetPhysicalDeviceQueueFamilyProperties'));
      vkGetPhysicalDeviceMemoryProperties                := TvkGetPhysicalDeviceMemoryProperties               (GetProcAddress('vkGetPhysicalDeviceMemoryProperties'));
      vkGetDeviceProcAddr                                := TvkGetDeviceProcAddr                               (GetProcAddress('vkGetDeviceProcAddr'));
      vkCreateDevice                                     := TvkCreateDevice                                    (GetProcAddress('vkCreateDevice'));
      vkEnumerateDeviceExtensionProperties               := TvkEnumerateDeviceExtensionProperties              (GetProcAddress('vkEnumerateDeviceExtensionProperties'));
      vkEnumerateDeviceLayerProperties                   := TvkEnumerateDeviceLayerProperties                  (GetProcAddress('vkEnumerateDeviceLayerProperties'));
      vkGetPhysicalDeviceSparseImageFormatProperties     := TvkGetPhysicalDeviceSparseImageFormatProperties    (GetProcAddress('vkGetPhysicalDeviceSparseImageFormatProperties'));
      
      { ========================================== VK_KHR_surface ========================================== }
      vkDestroySurfaceKHR                                := TvkDestroySurfaceKHR                               (GetProcAddress('vkDestroySurfaceKHR'));
      vkGetPhysicalDeviceSurfaceSupportKHR               := TvkGetPhysicalDeviceSurfaceSupportKHR              (GetProcAddress('vkGetPhysicalDeviceSurfaceSupportKHR'));
      vkGetPhysicalDeviceSurfaceCapabilitiesKHR          := TvkGetPhysicalDeviceSurfaceCapabilitiesKHR         (GetProcAddress('vkGetPhysicalDeviceSurfaceCapabilitiesKHR'));
      vkGetPhysicalDeviceSurfaceFormatsKHR               := TvkGetPhysicalDeviceSurfaceFormatsKHR              (GetProcAddress('vkGetPhysicalDeviceSurfaceFormatsKHR'));
      vkGetPhysicalDeviceSurfacePresentModesKHR          := TvkGetPhysicalDeviceSurfacePresentModesKHR         (GetProcAddress('vkGetPhysicalDeviceSurfacePresentModesKHR'));
      
      { ========================================== VK_KHR_display ========================================== }
      vkGetPhysicalDeviceDisplayPropertiesKHR            := TvkGetPhysicalDeviceDisplayPropertiesKHR           (GetProcAddress('vkGetPhysicalDeviceDisplayPropertiesKHR'));
      vkGetPhysicalDeviceDisplayPlanePropertiesKHR       := TvkGetPhysicalDeviceDisplayPlanePropertiesKHR      (GetProcAddress('vkGetPhysicalDeviceDisplayPlanePropertiesKHR'));
      vkGetDisplayPlaneSupportedDisplaysKHR              := TvkGetDisplayPlaneSupportedDisplaysKHR             (GetProcAddress('vkGetDisplayPlaneSupportedDisplaysKHR'));
      vkGetDisplayModePropertiesKHR                      := TvkGetDisplayModePropertiesKHR                     (GetProcAddress('vkGetDisplayModePropertiesKHR'));
      vkCreateDisplayModeKHR                             := TvkCreateDisplayModeKHR                            (GetProcAddress('vkCreateDisplayModeKHR'));
      vkGetDisplayPlaneCapabilitiesKHR                   := TvkGetDisplayPlaneCapabilitiesKHR                  (GetProcAddress('vkGetDisplayPlaneCapabilitiesKHR'));
      vkCreateDisplayPlaneSurfaceKHR                     := TvkCreateDisplayPlaneSurfaceKHR                    (GetProcAddress('vkCreateDisplayPlaneSurfaceKHR'));
      
      { ======================================= VK_KHR_xlib_surface ======================================== }
      {$IFDEF VK_USE_PLATFORM_XLIB_KHR}
      vkCreateXlibSurfaceKHR                             := TvkCreateXlibSurfaceKHR                            (GetProcAddress('vkCreateXlibSurfaceKHR'));
      vkGetPhysicalDeviceXlibPresentationSupportKHR      := TvkGetPhysicalDeviceXlibPresentationSupportKHR     (GetProcAddress('vkGetPhysicalDeviceXlibPresentationSupportKHR'));
      {$ENDIF}
      
      { ======================================== VK_KHR_xcb_surface ======================================== }
      {$IFDEF VK_USE_PLATFORM_XCB_KHR}
      vkCreateXcbSurfaceKHR                              := TvkCreateXcbSurfaceKHR                             (GetProcAddress('vkCreateXcbSurfaceKHR'));
      vkGetPhysicalDeviceXcbPresentationSupportKHR       := TvkGetPhysicalDeviceXcbPresentationSupportKHR      (GetProcAddress('vkGetPhysicalDeviceXcbPresentationSupportKHR'));
      {$ENDIF}
      
      { ====================================== VK_KHR_wayland_surface ====================================== }
      {$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
      vkCreateWaylandSurfaceKHR                          := TvkCreateWaylandSurfaceKHR                         (GetProcAddress('vkCreateWaylandSurfaceKHR'));
      vkGetPhysicalDeviceWaylandPresentationSupportKHR   := TvkGetPhysicalDeviceWaylandPresentationSupportKHR  (GetProcAddress('vkGetPhysicalDeviceWaylandPresentationSupportKHR'));
      {$ENDIF}
      
      { ======================================== VK_KHR_mir_surface ======================================== }
      {$IFDEF VK_USE_PLATFORM_MIR_KHR}
      vkCreateMirSurfaceKHR                              := TvkCreateMirSurfaceKHR                             (GetProcAddress('vkCreateMirSurfaceKHR'));
      vkGetPhysicalDeviceMirPresentationSupportKHR       := TvkGetPhysicalDeviceMirPresentationSupportKHR      (GetProcAddress('vkGetPhysicalDeviceMirPresentationSupportKHR'));
      {$ENDIF}
      
      { ====================================== VK_KHR_android_surface ====================================== }
      {$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
      vkCreateAndroidSurfaceKHR                          := TvkCreateAndroidSurfaceKHR                         (GetProcAddress('vkCreateAndroidSurfaceKHR'));
      {$ENDIF}
      
      { ======================================= VK_KHR_win32_surface ======================================= }
      {$IFDEF VK_USE_PLATFORM_WIN32_KHR}
      vkCreateWin32SurfaceKHR                            := TvkCreateWin32SurfaceKHR                           (GetProcAddress('vkCreateWin32SurfaceKHR'));
      vkGetPhysicalDeviceWin32PresentationSupportKHR     := TvkGetPhysicalDeviceWin32PresentationSupportKHR    (GetProcAddress('vkGetPhysicalDeviceWin32PresentationSupportKHR'));
      {$ENDIF}
      
      { ======================================= VK_EXT_debug_report ======================================== }
      vkCreateDebugReportCallbackEXT                     := TvkCreateDebugReportCallbackEXT                    (GetProcAddress('vkCreateDebugReportCallbackEXT'));
      vkDestroyDebugReportCallbackEXT                    := TvkDestroyDebugReportCallbackEXT                   (GetProcAddress('vkDestroyDebugReportCallbackEXT'));
      vkDebugReportMessageEXT                            := TvkDebugReportMessageEXT                           (GetProcAddress('vkDebugReportMessageEXT'));

    end;
  except
    FreeAndNil(result);
    raise;
  end;
end;

function LoadDeviceCommands(const aInstance: VkInstance; const aDevice: VkDevice): TVkDeviceCommands;
var
  vkGetDeviceProcAddr: TvkGetDeviceProcAddr;

  function GetProcAddress(const aName: String): TvkVoidFunction;
  begin
    result := vkGetDeviceProcAddr(aDevice, PVkChar(aName));
  end;

begin
  vkGetDeviceProcAddr := TvkGetDeviceProcAddr(vkGetInstanceProcAddr(aInstance, 'vkGetDeviceProcAddr'));
  result := TVkDeviceCommands.Create;
  try
    result.Device := aDevice;
    with result do begin
      
      { ========================================== VK_VERSION_1_0 ========================================== }
      vkDestroyDevice                                    := TvkDestroyDevice                                   (GetProcAddress('vkDestroyDevice'));
      vkGetDeviceQueue                                   := TvkGetDeviceQueue                                  (GetProcAddress('vkGetDeviceQueue'));
      vkQueueSubmit                                      := TvkQueueSubmit                                     (GetProcAddress('vkQueueSubmit'));
      vkQueueWaitIdle                                    := TvkQueueWaitIdle                                   (GetProcAddress('vkQueueWaitIdle'));
      vkDeviceWaitIdle                                   := TvkDeviceWaitIdle                                  (GetProcAddress('vkDeviceWaitIdle'));
      vkAllocateMemory                                   := TvkAllocateMemory                                  (GetProcAddress('vkAllocateMemory'));
      vkFreeMemory                                       := TvkFreeMemory                                      (GetProcAddress('vkFreeMemory'));
      vkMapMemory                                        := TvkMapMemory                                       (GetProcAddress('vkMapMemory'));
      vkUnmapMemory                                      := TvkUnmapMemory                                     (GetProcAddress('vkUnmapMemory'));
      vkFlushMappedMemoryRanges                          := TvkFlushMappedMemoryRanges                         (GetProcAddress('vkFlushMappedMemoryRanges'));
      vkInvalidateMappedMemoryRanges                     := TvkInvalidateMappedMemoryRanges                    (GetProcAddress('vkInvalidateMappedMemoryRanges'));
      vkGetDeviceMemoryCommitment                        := TvkGetDeviceMemoryCommitment                       (GetProcAddress('vkGetDeviceMemoryCommitment'));
      vkBindBufferMemory                                 := TvkBindBufferMemory                                (GetProcAddress('vkBindBufferMemory'));
      vkBindImageMemory                                  := TvkBindImageMemory                                 (GetProcAddress('vkBindImageMemory'));
      vkGetBufferMemoryRequirements                      := TvkGetBufferMemoryRequirements                     (GetProcAddress('vkGetBufferMemoryRequirements'));
      vkGetImageMemoryRequirements                       := TvkGetImageMemoryRequirements                      (GetProcAddress('vkGetImageMemoryRequirements'));
      vkGetImageSparseMemoryRequirements                 := TvkGetImageSparseMemoryRequirements                (GetProcAddress('vkGetImageSparseMemoryRequirements'));
      vkQueueBindSparse                                  := TvkQueueBindSparse                                 (GetProcAddress('vkQueueBindSparse'));
      vkCreateFence                                      := TvkCreateFence                                     (GetProcAddress('vkCreateFence'));
      vkDestroyFence                                     := TvkDestroyFence                                    (GetProcAddress('vkDestroyFence'));
      vkResetFences                                      := TvkResetFences                                     (GetProcAddress('vkResetFences'));
      vkGetFenceStatus                                   := TvkGetFenceStatus                                  (GetProcAddress('vkGetFenceStatus'));
      vkWaitForFences                                    := TvkWaitForFences                                   (GetProcAddress('vkWaitForFences'));
      vkCreateSemaphore                                  := TvkCreateSemaphore                                 (GetProcAddress('vkCreateSemaphore'));
      vkDestroySemaphore                                 := TvkDestroySemaphore                                (GetProcAddress('vkDestroySemaphore'));
      vkCreateEvent                                      := TvkCreateEvent                                     (GetProcAddress('vkCreateEvent'));
      vkDestroyEvent                                     := TvkDestroyEvent                                    (GetProcAddress('vkDestroyEvent'));
      vkGetEventStatus                                   := TvkGetEventStatus                                  (GetProcAddress('vkGetEventStatus'));
      vkSetEvent                                         := TvkSetEvent                                        (GetProcAddress('vkSetEvent'));
      vkResetEvent                                       := TvkResetEvent                                      (GetProcAddress('vkResetEvent'));
      vkCreateQueryPool                                  := TvkCreateQueryPool                                 (GetProcAddress('vkCreateQueryPool'));
      vkDestroyQueryPool                                 := TvkDestroyQueryPool                                (GetProcAddress('vkDestroyQueryPool'));
      vkGetQueryPoolResults                              := TvkGetQueryPoolResults                             (GetProcAddress('vkGetQueryPoolResults'));
      vkCreateBuffer                                     := TvkCreateBuffer                                    (GetProcAddress('vkCreateBuffer'));
      vkDestroyBuffer                                    := TvkDestroyBuffer                                   (GetProcAddress('vkDestroyBuffer'));
      vkCreateBufferView                                 := TvkCreateBufferView                                (GetProcAddress('vkCreateBufferView'));
      vkDestroyBufferView                                := TvkDestroyBufferView                               (GetProcAddress('vkDestroyBufferView'));
      vkCreateImage                                      := TvkCreateImage                                     (GetProcAddress('vkCreateImage'));
      vkDestroyImage                                     := TvkDestroyImage                                    (GetProcAddress('vkDestroyImage'));
      vkGetImageSubresourceLayout                        := TvkGetImageSubresourceLayout                       (GetProcAddress('vkGetImageSubresourceLayout'));
      vkCreateImageView                                  := TvkCreateImageView                                 (GetProcAddress('vkCreateImageView'));
      vkDestroyImageView                                 := TvkDestroyImageView                                (GetProcAddress('vkDestroyImageView'));
      vkCreateShaderModule                               := TvkCreateShaderModule                              (GetProcAddress('vkCreateShaderModule'));
      vkDestroyShaderModule                              := TvkDestroyShaderModule                             (GetProcAddress('vkDestroyShaderModule'));
      vkCreatePipelineCache                              := TvkCreatePipelineCache                             (GetProcAddress('vkCreatePipelineCache'));
      vkDestroyPipelineCache                             := TvkDestroyPipelineCache                            (GetProcAddress('vkDestroyPipelineCache'));
      vkGetPipelineCacheData                             := TvkGetPipelineCacheData                            (GetProcAddress('vkGetPipelineCacheData'));
      vkMergePipelineCaches                              := TvkMergePipelineCaches                             (GetProcAddress('vkMergePipelineCaches'));
      vkCreateGraphicsPipelines                          := TvkCreateGraphicsPipelines                         (GetProcAddress('vkCreateGraphicsPipelines'));
      vkCreateComputePipelines                           := TvkCreateComputePipelines                          (GetProcAddress('vkCreateComputePipelines'));
      vkDestroyPipeline                                  := TvkDestroyPipeline                                 (GetProcAddress('vkDestroyPipeline'));
      vkCreatePipelineLayout                             := TvkCreatePipelineLayout                            (GetProcAddress('vkCreatePipelineLayout'));
      vkDestroyPipelineLayout                            := TvkDestroyPipelineLayout                           (GetProcAddress('vkDestroyPipelineLayout'));
      vkCreateSampler                                    := TvkCreateSampler                                   (GetProcAddress('vkCreateSampler'));
      vkDestroySampler                                   := TvkDestroySampler                                  (GetProcAddress('vkDestroySampler'));
      vkCreateDescriptorSetLayout                        := TvkCreateDescriptorSetLayout                       (GetProcAddress('vkCreateDescriptorSetLayout'));
      vkDestroyDescriptorSetLayout                       := TvkDestroyDescriptorSetLayout                      (GetProcAddress('vkDestroyDescriptorSetLayout'));
      vkCreateDescriptorPool                             := TvkCreateDescriptorPool                            (GetProcAddress('vkCreateDescriptorPool'));
      vkDestroyDescriptorPool                            := TvkDestroyDescriptorPool                           (GetProcAddress('vkDestroyDescriptorPool'));
      vkResetDescriptorPool                              := TvkResetDescriptorPool                             (GetProcAddress('vkResetDescriptorPool'));
      vkAllocateDescriptorSets                           := TvkAllocateDescriptorSets                          (GetProcAddress('vkAllocateDescriptorSets'));
      vkFreeDescriptorSets                               := TvkFreeDescriptorSets                              (GetProcAddress('vkFreeDescriptorSets'));
      vkUpdateDescriptorSets                             := TvkUpdateDescriptorSets                            (GetProcAddress('vkUpdateDescriptorSets'));
      vkCreateFramebuffer                                := TvkCreateFramebuffer                               (GetProcAddress('vkCreateFramebuffer'));
      vkDestroyFramebuffer                               := TvkDestroyFramebuffer                              (GetProcAddress('vkDestroyFramebuffer'));
      vkCreateRenderPass                                 := TvkCreateRenderPass                                (GetProcAddress('vkCreateRenderPass'));
      vkDestroyRenderPass                                := TvkDestroyRenderPass                               (GetProcAddress('vkDestroyRenderPass'));
      vkGetRenderAreaGranularity                         := TvkGetRenderAreaGranularity                        (GetProcAddress('vkGetRenderAreaGranularity'));
      vkCreateCommandPool                                := TvkCreateCommandPool                               (GetProcAddress('vkCreateCommandPool'));
      vkDestroyCommandPool                               := TvkDestroyCommandPool                              (GetProcAddress('vkDestroyCommandPool'));
      vkResetCommandPool                                 := TvkResetCommandPool                                (GetProcAddress('vkResetCommandPool'));
      vkAllocateCommandBuffers                           := TvkAllocateCommandBuffers                          (GetProcAddress('vkAllocateCommandBuffers'));
      vkFreeCommandBuffers                               := TvkFreeCommandBuffers                              (GetProcAddress('vkFreeCommandBuffers'));
      vkBeginCommandBuffer                               := TvkBeginCommandBuffer                              (GetProcAddress('vkBeginCommandBuffer'));
      vkEndCommandBuffer                                 := TvkEndCommandBuffer                                (GetProcAddress('vkEndCommandBuffer'));
      vkResetCommandBuffer                               := TvkResetCommandBuffer                              (GetProcAddress('vkResetCommandBuffer'));
      vkCmdBindPipeline                                  := TvkCmdBindPipeline                                 (GetProcAddress('vkCmdBindPipeline'));
      vkCmdSetViewport                                   := TvkCmdSetViewport                                  (GetProcAddress('vkCmdSetViewport'));
      vkCmdSetScissor                                    := TvkCmdSetScissor                                   (GetProcAddress('vkCmdSetScissor'));
      vkCmdSetLineWidth                                  := TvkCmdSetLineWidth                                 (GetProcAddress('vkCmdSetLineWidth'));
      vkCmdSetDepthBias                                  := TvkCmdSetDepthBias                                 (GetProcAddress('vkCmdSetDepthBias'));
      vkCmdSetBlendConstants                             := TvkCmdSetBlendConstants                            (GetProcAddress('vkCmdSetBlendConstants'));
      vkCmdSetDepthBounds                                := TvkCmdSetDepthBounds                               (GetProcAddress('vkCmdSetDepthBounds'));
      vkCmdSetStencilCompareMask                         := TvkCmdSetStencilCompareMask                        (GetProcAddress('vkCmdSetStencilCompareMask'));
      vkCmdSetStencilWriteMask                           := TvkCmdSetStencilWriteMask                          (GetProcAddress('vkCmdSetStencilWriteMask'));
      vkCmdSetStencilReference                           := TvkCmdSetStencilReference                          (GetProcAddress('vkCmdSetStencilReference'));
      vkCmdBindDescriptorSets                            := TvkCmdBindDescriptorSets                           (GetProcAddress('vkCmdBindDescriptorSets'));
      vkCmdBindIndexBuffer                               := TvkCmdBindIndexBuffer                              (GetProcAddress('vkCmdBindIndexBuffer'));
      vkCmdBindVertexBuffers                             := TvkCmdBindVertexBuffers                            (GetProcAddress('vkCmdBindVertexBuffers'));
      vkCmdDraw                                          := TvkCmdDraw                                         (GetProcAddress('vkCmdDraw'));
      vkCmdDrawIndexed                                   := TvkCmdDrawIndexed                                  (GetProcAddress('vkCmdDrawIndexed'));
      vkCmdDrawIndirect                                  := TvkCmdDrawIndirect                                 (GetProcAddress('vkCmdDrawIndirect'));
      vkCmdDrawIndexedIndirect                           := TvkCmdDrawIndexedIndirect                          (GetProcAddress('vkCmdDrawIndexedIndirect'));
      vkCmdDispatch                                      := TvkCmdDispatch                                     (GetProcAddress('vkCmdDispatch'));
      vkCmdDispatchIndirect                              := TvkCmdDispatchIndirect                             (GetProcAddress('vkCmdDispatchIndirect'));
      vkCmdCopyBuffer                                    := TvkCmdCopyBuffer                                   (GetProcAddress('vkCmdCopyBuffer'));
      vkCmdCopyImage                                     := TvkCmdCopyImage                                    (GetProcAddress('vkCmdCopyImage'));
      vkCmdBlitImage                                     := TvkCmdBlitImage                                    (GetProcAddress('vkCmdBlitImage'));
      vkCmdCopyBufferToImage                             := TvkCmdCopyBufferToImage                            (GetProcAddress('vkCmdCopyBufferToImage'));
      vkCmdCopyImageToBuffer                             := TvkCmdCopyImageToBuffer                            (GetProcAddress('vkCmdCopyImageToBuffer'));
      vkCmdUpdateBuffer                                  := TvkCmdUpdateBuffer                                 (GetProcAddress('vkCmdUpdateBuffer'));
      vkCmdFillBuffer                                    := TvkCmdFillBuffer                                   (GetProcAddress('vkCmdFillBuffer'));
      vkCmdClearColorImage                               := TvkCmdClearColorImage                              (GetProcAddress('vkCmdClearColorImage'));
      vkCmdClearDepthStencilImage                        := TvkCmdClearDepthStencilImage                       (GetProcAddress('vkCmdClearDepthStencilImage'));
      vkCmdClearAttachments                              := TvkCmdClearAttachments                             (GetProcAddress('vkCmdClearAttachments'));
      vkCmdResolveImage                                  := TvkCmdResolveImage                                 (GetProcAddress('vkCmdResolveImage'));
      vkCmdSetEvent                                      := TvkCmdSetEvent                                     (GetProcAddress('vkCmdSetEvent'));
      vkCmdResetEvent                                    := TvkCmdResetEvent                                   (GetProcAddress('vkCmdResetEvent'));
      vkCmdWaitEvents                                    := TvkCmdWaitEvents                                   (GetProcAddress('vkCmdWaitEvents'));
      vkCmdPipelineBarrier                               := TvkCmdPipelineBarrier                              (GetProcAddress('vkCmdPipelineBarrier'));
      vkCmdBeginQuery                                    := TvkCmdBeginQuery                                   (GetProcAddress('vkCmdBeginQuery'));
      vkCmdEndQuery                                      := TvkCmdEndQuery                                     (GetProcAddress('vkCmdEndQuery'));
      vkCmdResetQueryPool                                := TvkCmdResetQueryPool                               (GetProcAddress('vkCmdResetQueryPool'));
      vkCmdWriteTimestamp                                := TvkCmdWriteTimestamp                               (GetProcAddress('vkCmdWriteTimestamp'));
      vkCmdCopyQueryPoolResults                          := TvkCmdCopyQueryPoolResults                         (GetProcAddress('vkCmdCopyQueryPoolResults'));
      vkCmdPushConstants                                 := TvkCmdPushConstants                                (GetProcAddress('vkCmdPushConstants'));
      vkCmdBeginRenderPass                               := TvkCmdBeginRenderPass                              (GetProcAddress('vkCmdBeginRenderPass'));
      vkCmdNextSubpass                                   := TvkCmdNextSubpass                                  (GetProcAddress('vkCmdNextSubpass'));
      vkCmdEndRenderPass                                 := TvkCmdEndRenderPass                                (GetProcAddress('vkCmdEndRenderPass'));
      vkCmdExecuteCommands                               := TvkCmdExecuteCommands                              (GetProcAddress('vkCmdExecuteCommands'));
      
      { ========================================= VK_KHR_swapchain ========================================= }
      vkCreateSwapchainKHR                               := TvkCreateSwapchainKHR                              (GetProcAddress('vkCreateSwapchainKHR'));
      vkDestroySwapchainKHR                              := TvkDestroySwapchainKHR                             (GetProcAddress('vkDestroySwapchainKHR'));
      vkGetSwapchainImagesKHR                            := TvkGetSwapchainImagesKHR                           (GetProcAddress('vkGetSwapchainImagesKHR'));
      vkAcquireNextImageKHR                              := TvkAcquireNextImageKHR                             (GetProcAddress('vkAcquireNextImageKHR'));
      vkQueuePresentKHR                                  := TvkQueuePresentKHR                                 (GetProcAddress('vkQueuePresentKHR'));
      
      { ===================================== VK_KHR_display_swapchain ===================================== }
      vkCreateSharedSwapchainsKHR                        := TvkCreateSharedSwapchainsKHR                       (GetProcAddress('vkCreateSharedSwapchainsKHR'));

    end;
  except
    FreeAndNil(result);
    raise;
  end;
end;

procedure FinalizeVulkan;
begin
  vkFreeLibrary(vkLibHandle);
end;

initialization

finalization
  FinalizeVulkan;

end.
